using Terraria.ID;
using System.Diagnostics;
using Terraria;
using Terraria.ModLoader;
using SOTS.Items.Otherworld;
using Microsoft.Xna.Framework;
using SOTS.Items.Pyramid;
using SOTS.Items.ChestItems;
using System;
using SOTS.Items;
using SOTS.Items.Pyramid.AncientGold;
using SOTS.Items.Pyramid.PyramidWalls;
using SOTS.Items.Tide;
using SOTS.Items.Permafrost;
using SOTS.Items.Secrets;
using SOTS.Items.GhostTown;

namespace SOTS
{
	public class SOTSWorldgenHelper
	{
		public static bool TrueTileSolid(int i, int j)
		{
			return (!WorldGen.InWorld(i, j, 20) || Main.tile[i, j].active() && Main.tileSolidTop[Main.tile[i, j].type] == false && Main.tileSolid[Main.tile[i, j].type] == true && Main.tile[i, j].nactive());
		}
		public static void GenerateAcediaRoom(int x, int y, Mod mod, int direction = 1)
		{
			if (direction != 1 && direction != -1)
			{
				return;
			}
			int spawnX = x;
			int spawnY = y;
			int[,] _structure = {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,3,3,3,4,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,4,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1,1,1,1,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,1,1,1,1,1,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,0,0,0,0,0,0,0},
				{0,0,0,1,1,1,1,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1,1,1,1,1,1,1,1,1,1,0,0},
				{0,0,0,1,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1,1,1,1,1,1,1,1,1,0},
				{1,1,1,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1,1,1,1},
				{1,1,1,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1},
				{0,1,1,1,5,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1},
				{0,0,1,1,1,1,7,3,3,3,6,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,8,1},
				{0,0,0,0,1,1,1,1,1,1,1,1,1,1,7,7,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,7,7,1,1,1},
				{0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,7,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,8,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,3,9,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,7,7,7,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{0,0,0,0,1,1,1,1,3,1,3,3,3,4,1,1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,7,7,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0},
				{0,0,0,1,1,1,1,1,5,1,3,1,3,3,3,3,1,1,1,1,1,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,8,1,1,1,1,1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,0,0,0,0,0,0},
				{0,0,0,1,1,1,1,1,1,1,1,1,3,8,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,2,3,3,7,3,1,1,3,8,1,1,1,1,1,1,0,0,0,0,0,0},
				{0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1,1,1,1,3,3,3,3,3,8,1,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0},
				{0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1,1,1,1,5,3,3,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,1,1,1,1,11,11,11,11,11,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,11,11,11,11,11,1,1,1,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,1,1,1,11,11,3,3,3,11,11,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,11,11,3,3,3,11,11,1,1,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,1,1,11,3,3,3,3,3,11,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,11,3,3,3,3,3,11,1,1,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,1,1,11,3,3,3,3,3,11,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,11,3,3,3,3,3,11,1,1,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,1,1,11,3,3,3,3,3,11,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,11,3,3,3,3,3,11,1,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,1,11,11,3,3,3,11,11,1,1,7,7,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,11,11,3,3,3,11,11,1,1,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,1,1,1,11,11,11,11,11,1,1,1,1,1,1,7,3,3,3,3,3,3,3,3,10,3,3,3,3,3,3,3,7,1,1,1,1,1,1,1,11,11,11,11,11,1,1,1,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,1,1,1,1,11,1,1,1,1,1,1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,1,1,1,1,1,11,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,1,11,1,1,1,1,1,1,1,11,0,0,0,0,0,0,11,11,11,11,11,11,11,0,0,0,0,0,0,11,1,1,1,1,1,1,1,11,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,11,11,11,11,11,11,11,11,11,0,0,0,0,0,0,0,11,0,11,0,11,0,0,0,0,0,0,0,11,11,11,11,11,11,11,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
			};
			int PosX = spawnX - ((_structure.GetLength(1) - 1) * direction); //spawnX and spawnY is where you want the anchor to be when this generates
			int PosY = spawnY - 13;

			for (int i = -4; i < _structure.GetLength(0) + 4; i++)
			{
				for (int j = _structure.GetLength(1) + 3; j >= -4; j--)
				{
					int k = PosX + (j * direction);
					int l = PosY + i;
					if (WorldGen.InWorld(k, l, 30))
					{
						Tile tile = Framing.GetTileSafely(k, l);
						tile.active(true);
						tile.type = (ushort)ModContent.TileType<PyramidSlabTile>();
						tile.slope(0);
						tile.halfBrick(false);
					}
				}
			}
			//i = vertical, j = horizontal
			for (int confirmPlatforms = 0; confirmPlatforms < 3; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
			{
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + (j * direction);
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<PyramidSlabTile>();
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 1:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<OvergrownPyramidTile>();
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 2:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<OvergrownPyramidTile>();
									tile.slope((byte)(direction == 1 ? 3 : 4));
									tile.halfBrick(false);
									break;
								case 3:
									if (confirmPlatforms == 0)
									{
										tile.active(false);
										tile.halfBrick(false);
										tile.slope(0);
									}
									break;
								case 4:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<OvergrownPyramidTile>();
									tile.slope((byte)(direction == 1 ? 4 : 3));
									tile.halfBrick(false);
									break;
								case 5:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<OvergrownPyramidTile>();
									tile.slope((byte)(direction == 1 ? 1 : 2));
									tile.halfBrick(false);
									break;
								case 6:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k - (direction == 1 ? 1 : 0), l, (ushort)ModContent.TileType<CursedAppleTile>(), true, true, -1, 0);
									}
									break;
								case 7:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<OvergrownPyramidTile>();
									tile.slope(0);
									tile.halfBrick(true);
									break;
								case 8:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<OvergrownPyramidTile>();
									tile.slope((byte)(direction == 1 ? 2 : 1));
									tile.halfBrick(false);
									break;
								case 9:
									if (confirmPlatforms == 0)
									{
										tile.active(false);
										tile.halfBrick(false);
										tile.slope(0);
									}
									break;
								case 10:
									if (confirmPlatforms == 2)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<AcediaGatewayTile>(), true, true, -1, 0);
									}
									break;
								case 11:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<AcediaPlatingTile>();
									tile.slope(0);
									tile.halfBrick(false);
									break;
							}
						}
					}
				}
			}
			_structure = new int[,] {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,3,3,3,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2},
				{0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,2,2,2,2,3,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2},
				{0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,2,2,3,3,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2},
				{0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,4,5,5,5,5,5,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,4,5,5,5,5,5,5,5,4,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,4,5,5,5,5,5,5,5,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
			};
			//i = vertical, j = horizontal
			for (int i = 0; i < _structure.GetLength(0); i++)
			{
				for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
				{
					int k = PosX + (j * direction);
					int l = PosY + i;
					if (WorldGen.InWorld(k, l, 30))
					{
						Tile tile = Framing.GetTileSafely(k, l);
						switch (_structure[i, j])
						{
							case 0:
								tile.wall = (ushort)ModContent.WallType<UnsafePyramidWallWall>();
								break;
							case 1:
								tile.wall = (ushort)ModContent.WallType<UnsafeOvergrownPyramidWallWall>();
								break;
							case 2:
								tile.wall = (ushort)ModContent.WallType<UnsafePyramidBrickWallWall>();
								break;
							case 3:
								tile.wall = (ushort)ModContent.WallType<AncientGoldBrickWallTile>();
								break;
							case 4:
								tile.wall = (ushort)ModContent.WallType<UnsafeAcediaWallWall>();
								break;
							case 5:
								tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
								break;
							case 6:
								tile.wall = (ushort)ModContent.WallType<UnsafeAcediaWallWall>();
								break;
						}
					}
				}
			}
		}
		public static bool Full(int x, int y, int lengthX, int lengthY)
		{
			int counting = 0;
			for (int i = 0; i < lengthY; i++)
			{
				for (int j = 0; j < lengthX; j++)
				{
					int k = x + j;
					int l = y + i;
					if (WorldGen.InWorld(k, l, 30))
					{
						Tile tile = Framing.GetTileSafely(k, l);
						if (tile.active())
						{
							counting++;
						}
					}
				}
			}
			if (counting >= lengthX * lengthY)
				return true;
			return false;
		}
		public static bool Empty(int x, int y, int lengthX, int lengthY, int max = 1)
		{
			for (int i = 0; i < lengthY; i++)
			{
				for (int j = 0; j < lengthX; j++)
				{
					int k = x + j;
					int l = y + i;
					if (WorldGen.InWorld(k, l, 30))
					{
						Tile tile = Framing.GetTileSafely(k, l);
						if (tile.active())
						{
							return false;
						}
					}
					else
					{
						return false;
					}
				}
			}
			return true;
		}
		public static bool GenerateSkyArtifact(int x, int y, Mod mod, bool force = false)
		{
			int[,] _structure = {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,8,1,1,1,1,1,1,1,8,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,9,9,9,9,9,9,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,9,9,9,9,9,9,9,9,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,9,9,9,9,9,9,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,2,2,2,2,2,2,1,1,3,3,3,3,3,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,3,3,3,3,3,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,2,2,2,2,2,2,1,3,3,3,3,3,3,3,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,3,3,0,0,0,3,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,2,2,2,2,2,2,1,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,2,2,2,2,2,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,0,0,0,0,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,2,2,2,2,2,1,3,3,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,2,2,2,2,1,3,3,3,3,3,3,3,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,4,0,0,5,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,3,3,0,0,0,3,3,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,2,2,2,1,1,3,3,3,3,3,1,1,2,2,2,2,2,2,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,3,3,3,3,3,1,1,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,2,2,2,1,1,1,1,1,1,1,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,10},
				{0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,3,3,3,3,3},
				{0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,6},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2}
			};
			int PosX = x;    //spawnX and spawnY is where you want the anchor to be when this generates
			int PosY = y - 40;

			if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5) && !force)
			{
				return false;
			}
			//i = vertical, j = horizontal
			for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
			{
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = 0; j < _structure.GetLength(1); j++)
					{
						int k = PosX + j;
						int l = PosY + i;
						int k2 = PosX - j;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							Tile tile2 = Framing.GetTileSafely(k2, l);
							switch (_structure[i, _structure.GetLength(1) - j - 1])
							{
								case 0:
									if (confirmPlatforms == 0)
									{
										tile.active(false);
										tile.halfBrick(false);
										tile.slope(0);
									}
									break;
								case 1:
									tile.active(true);
									tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
									tile.slope(0);
									tile.halfBrick(false);

									tile2.active(true);
									tile2.type = (ushort)mod.TileType("AvaritianPlatingTile");
									tile2.slope(0);
									tile2.halfBrick(false);
									break;
								case 2:
									tile.active(true);
									tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
									tile.type = (ushort)mod.TileType("DullPlatingTile");
									tile.slope(0);
									tile.halfBrick(false);

									tile2.active(true);
									tile2.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
									tile2.type = (ushort)mod.TileType("DullPlatingTile");
									tile2.slope(0);
									tile2.halfBrick(false);
									break;
								case 3:
									tile.active(true);
									tile.type = (ushort)mod.TileType("PortalPlatingTile");
									tile.slope(0);
									tile.halfBrick(false);

									tile2.active(true);
									tile2.type = (ushort)mod.TileType("PortalPlatingTile");
									tile2.slope(0);
									tile2.halfBrick(false);
									break;
								case 4:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, mod.TileType("CrystalStatue"), true, true, -1, 1);

										tile2.active(false);
										tile2.slope(0);
										tile2.halfBrick(false);
										WorldGen.PlaceTile(k2 - 1, l, mod.TileType("CrystalStatue"), true, true, -1, 1);
									}
									break;
								case 5:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceChest(k, l, (ushort)ModContent.TileType<LockedStrangeChest>(), style: 1);

										tile2.active(false);
										tile2.slope(0);
										tile2.halfBrick(false);
										WorldGen.PlaceChest(k2 - 1, l, (ushort)ModContent.TileType<LockedStrangeChest>(), style: 1);
									}
									break;
								case 6:
									tile.active(true);
									tile.type = (ushort)mod.TileType("PortalPlatingTile");
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 7:
									tile.active(false);
									tile.slope(0);
									tile.halfBrick(false);
									WorldGen.PlaceTile(k, l, mod.TileType("SkyChainTile"), true, true, -1, 0);

									tile2.active(false);
									tile2.slope(0);
									tile2.halfBrick(false);
									WorldGen.PlaceTile(k2, l, mod.TileType("SkyChainTile"), true, true, -1, 0);
									break;
								case 8:
									tile.active(true);
									tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
									tile.slope(0);
									tile.halfBrick(false);

									tile2.active(true);
									tile2.type = (ushort)mod.TileType("AvaritianPlatingTile");
									tile2.slope(0);
									tile2.halfBrick(false);

									Tile tile3 = Framing.GetTileSafely(k, l - 1);
									Tile tile4 = Framing.GetTileSafely(k2, l - 1);
									tile3.active(false);
									tile3.slope(0);
									tile3.halfBrick(false);
									WorldGen.PlaceTile(k, l - 1, mod.TileType("SkyChainTile"), true, true, -1, 0);

									tile4.active(false);
									tile4.slope(0);
									tile4.halfBrick(false);
									WorldGen.PlaceTile(k2, l - 1, mod.TileType("SkyChainTile"), true, true, -1, 0);
									break;
								case 9:
									tile.active(true);
									tile.type = (ushort)mod.TileType("DullPlatingTile");
									tile.slope(0);
									tile.halfBrick(false);
									tile2.active(true);
									tile2.type = (ushort)mod.TileType("DullPlatingTile");
									tile2.slope(0);
									tile2.halfBrick(false);
									break;
								case 10:
									tile.active(false);
									tile.slope(0);
									tile.halfBrick(false);
									WorldGen.PlaceTile(k, l, mod.TileType("AvaritianGatewayTile"), true, true, -1, 0);
									break;
							}
						}
					}
				}
			}
			int[,] _structure2 = {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,3,3,3,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,2,2,3,3,3,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,3,3,3,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,2,2,3,3,3,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,3,3,3,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,3,3,3,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,2,2,2,1,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,2,2,2,2,1,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
				{0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
				{0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
				{0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
				{0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3},
				{0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
			};
			//i = vertical, j = horizontal
			for (int i = 0; i < _structure2.GetLength(0); i++)
			{
				for (int j = 0; j < _structure2.GetLength(1); j++)
				{
					int k = PosX + j;
					int l = PosY + i;
					int k2 = PosX - j;
					if (WorldGen.InWorld(k, l, 30))
					{
						Tile tile = Framing.GetTileSafely(k, l);
						Tile tile2 = Framing.GetTileSafely(k2, l);
						switch (_structure2[i, _structure2.GetLength(1) - j - 1])
						{
							case 0:
								//tile.wall = 0;
								break;
							case 1:
								tile.wall = (ushort)mod.WallType("PortalPlatingWallWall");
								tile2.wall = (ushort)mod.WallType("PortalPlatingWallWall");
								break;
							case 2:
								tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
								tile2.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
								break;
							case 3:
								tile.wall = (ushort)ModContent.WallType<HologlassWallWall>();
								tile2.wall = (ushort)ModContent.WallType<HologlassWallWall>();
								break;
						}
					}
				}
			}
			return true;
		}
		public static bool GenerateArtifactIslands(int x, int y, int type, Mod mod, int x2 = -1, int y2 = -1)
		{
			if (type == 0)
			{
				int[,] _structure = {
				{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
				{2,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2},
				{0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0},
				{0,0,4,4,4,4,4,4,4,5,4,4,4,4,4,4,4,0,0},
				{0,0,0,4,4,0,0,4,4,4,4,4,0,0,4,4,0,0,0},
				{0,0,0,4,0,0,0,0,4,4,4,0,0,0,0,4,0,0,0},
				{0,0,0,4,0,0,0,0,4,4,4,0,0,0,0,4,0,0,0},
				{0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0}
				};
				int PosX = x - 9;  //spawnX and spawnY is where you want the anchor to be when this generates
				int PosY = y - 1;

				if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5))
				{
					return false;
				}
				//i = vertical, j = horizontal
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										break;
									case 1:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, mod.TileType("SkyChainTile"), true, true, -1, 0);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 4:
										tile.active(true);
										tile.type = (ushort)mod.TileType("DullPlatingTile");
										tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 5:
										tile.active(true);
										tile.type = (ushort)mod.TileType("PortalPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
			}
			if (type == 1)
			{
				int[,] _structure = {
				{0,0,0,1,1,1,1,1,1,1,1,1,0,0,0},
				{0,0,0,0,2,2,2,2,2,2,2,0,0,0,0},
				{0,0,0,1,1,1,1,1,1,1,1,1,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{1,1,1,1,1,1,1,3,1,1,1,1,1,1,1},
				{0,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,0,0,2,2,2,2,2,2,2,2,2,0,0,0},
				{0,0,0,0,2,2,2,2,2,2,2,0,0,0,0},
				{0,0,0,0,0,2,2,2,2,2,0,0,0,0,0},
				{0,0,0,0,0,2,2,2,2,2,0,0,0,0,0},
				{0,0,0,0,0,0,2,2,2,0,0,0,0,0,0},
				{0,0,0,0,0,0,2,2,2,0,0,0,0,0,0},
				{0,0,0,0,0,0,2,2,2,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,2,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,2,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,2,0,0,0,0,0,0,0}
				};
				int PosX = x - 7;  //spawnX and spawnY is where you want the anchor to be when this generates
				int PosY = y - 7;
				if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5))
				{
					return false;
				}
				//i = vertical, j = horizontal
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										break;
									case 1:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = (ushort)mod.TileType("DullPlatingTile");
										tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				int[,] _structure2 = {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,1,0,0,0,1,0,0,0,0,0},
				{0,0,0,0,0,1,0,0,0,1,0,0,0,0,0},
				{0,0,0,0,0,1,0,0,0,1,0,0,0,0,0},
				{0,0,0,0,0,1,0,0,0,1,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
				};
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure2.GetLength(0); i++)
				{
					for (int j = _structure2.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure2[i, j])
							{
								case 0:
									break;
								case 1:
									tile.wall = (ushort)mod.WallType("PortalPlatingWallWall");
									break;
							}
						}
					}
				}
			}
			if (type == 2)
			{
				int[,] _structure = {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0},
				{1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1},
				{0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0},
				{1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1},
				{1,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,1},
				{1,1,1,2,2,2,2,2,2,2,2,2,2,2,1,1,1},
				{1,1,0,0,2,2,2,2,2,2,2,2,2,0,0,1,1},
				{1,1,1,1,2,2,2,2,2,2,2,2,2,1,1,1,1},
				{1,1,1,0,0,0,2,2,2,2,2,0,0,0,1,1,1},
				{1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,1},
				{1,1,1,1,0,0,0,2,2,2,0,0,0,1,1,1,1},
				{1,1,1,1,1,1,1,2,2,2,1,1,1,1,1,1,1},
				{1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1},
				{1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1}
				};
				int PosX = x - 8;  //spawnX and spawnY is where you want the anchor to be when this generates
				int PosY = y - 8;
				if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5))
				{
					return false;
				}
				//i = vertical, j = horizontal
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 1:
										break;
									case 2:
										tile.active(true);
										tile.type = (ushort)mod.TileType("DullPlatingTile");
										tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				int[,] _structure2 = {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
				{0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0},
				{0,1,2,3,3,3,3,3,3,3,3,3,3,3,2,1,0},
				{0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0},
				{0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
				};
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure2.GetLength(0); i++)
				{
					for (int j = _structure2.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure2[i, j])
							{
								case 0:
									break;
								case 1:
									tile.wall = (ushort)mod.WallType("PortalPlatingWallWall");
									break;
								case 2:
									tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
									break;
								case 3:
									tile.wall = (ushort)ModContent.WallType<HologlassWallWall>();
									break;
							}
						}
					}
				}
			}
			if (type == 3)
			{
				int[,] _structure = {
				{0,0,0,0,0,1,0,0,0,0,0},
				{0,0,0,0,2,2,2,0,0,0,0},
				{2,2,2,2,2,3,2,2,2,2,2},
				{0,4,4,4,2,2,2,4,4,4,0},
				{0,0,4,4,4,2,4,4,4,0,0},
				{0,0,0,4,4,2,4,4,0,0,0},
				{0,0,0,0,4,2,4,0,0,0,0},
				{0,0,0,0,0,2,0,0,0,0,0}
				};
				int PosX = x - 5;  //spawnX and spawnY is where you want the anchor to be when this generates
				int PosY = y - 2;
				if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5))
				{
					return false;
				}
				//i = vertical, j = horizontal
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										break;
									case 1:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, (ushort)mod.TileType("SkyChainTile"), true, true, -1, 0);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = (ushort)mod.TileType("PortalPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 4:
										tile.active(true);
										tile.type = (ushort)mod.TileType("DullPlatingTile");
										tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
			}
			if (type == 4)
			{
				int[,] _structure = {
				{0,1,1,1,1,1,1,1,1,1,1,1,0},
				{2,2,2,1,1,1,1,1,1,1,2,2,2},
				{2,3,2,2,2,2,2,2,2,2,2,3,2},
				{0,2,2,1,1,1,1,1,1,1,2,2,0},
				{0,0,0,0,1,1,1,1,1,0,2,0,0},
				{0,0,0,0,0,1,1,1,0,0,2,0,0},
				{0,0,0,0,0,1,1,1,0,0,2,0,0},
				{0,0,0,2,2,1,1,1,0,2,2,0,0},
				{0,0,2,2,0,1,1,1,2,2,0,0,0},
				{0,0,2,0,0,1,1,1,0,0,0,0,0},
				{0,0,2,0,0,1,1,1,0,0,0,0,0},
				{0,0,2,0,0,0,1,0,0,0,0,0,0},
				{0,0,2,2,0,0,1,0,0,0,0,0,0},
				{0,0,0,2,2,0,1,0,0,0,0,0,0},
				{0,0,0,0,2,2,2,2,0,0,0,0,0},
				{0,0,0,0,0,2,2,2,0,0,0,0,0},
				{0,0,0,0,0,0,2,0,0,0,0,0,0},
				{0,0,0,0,0,0,2,0,0,0,0,0,0}
				};
				int PosX = x - 6;  //spawnX and spawnY is where you want the anchor to be when this generates
				int PosY = y - 0;
				if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5))
				{
					return false;
				}
				//i = vertical, j = horizontal
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										break;
									case 1:
										tile.active(true);
										tile.type = (ushort)mod.TileType("DullPlatingTile");
										tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = (ushort)mod.TileType("PortalPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				int[,] _structure2 = {
				{0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,1,0,0,0},
				{0,0,0,0,0,0,0,0,1,1,0,0,0},
				{0,0,0,0,0,0,0,0,1,1,0,0,0},
				{0,0,0,0,0,0,0,0,1,0,0,0,0},
				{0,0,0,0,1,0,0,0,0,0,0,0,0},
				{0,0,0,1,1,0,0,0,0,0,0,0,0},
				{0,0,0,1,1,0,0,0,0,0,0,0,0},
				{0,0,0,1,1,1,2,0,0,0,0,0,0},
				{0,0,0,0,1,1,2,0,0,0,0,0,0},
				{0,0,0,0,0,1,2,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0}
				};
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure2.GetLength(0); i++)
				{
					for (int j = _structure2.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure2[i, j])
							{
								case 0:
									break;
								case 1:
									tile.wall = (ushort)mod.WallType("PortalPlatingWallWall");
									break;
								case 2:
									tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
									break;
							}
						}
					}
				}
			}
			if (type == 5)
			{
				int[,] _structure = {
				{0,1,1,1,1,1,1,1,0},
				{0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0},
				{1,1,1,1,1,1,1,1,1},
				{1,2,2,2,2,2,2,2,2},
				{1,1,1,1,1,1,1,1,0},
				{0,2,2,2,2,2,2,1,0},
				{0,0,1,1,1,1,1,1,0},
				{0,0,1,2,2,2,2,0,0},
				{0,0,1,1,1,1,0,0,0},
				{0,0,0,2,2,1,0,0,0},
				{0,0,0,0,1,1,0,0,0},
				{0,0,0,0,1,0,0,0,0}
				};
				int PosX = x - 4;  //spawnX and spawnY is where you want the anchor to be when this generates
				int PosY = y - 5;
				if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5))
				{
					return false;
				}
				//i = vertical, j = horizontal
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										break;
									case 1:
										tile.active(true);
										tile.type = (ushort)mod.TileType("DullPlatingTile");
										tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				int[,] _structure2 = {
				{0,0,0,0,0,0,0,0,0},
				{0,0,1,2,2,2,1,0,0},
				{0,0,1,2,3,2,1,0,0},
				{0,0,1,2,3,2,1,0,0},
				{0,0,1,2,2,2,1,0,0},
				{0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0}
				};
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure2.GetLength(0); i++)
				{
					for (int j = _structure2.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure2[i, j])
							{
								case 0:
									break;
								case 1:
									tile.wall = (ushort)mod.WallType("PortalPlatingWallWall");
									break;
								case 2:
									tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
									break;
								case 3:
									tile.wall = (ushort)ModContent.WallType<HologlassWallWall>();
									break;
							}
						}
					}
				}

			}
			if (type == 6)
			{
				int[,] _structure = {
				{0,0,0,0,1,0,0,0,0},
				{2,2,2,2,3,2,2,2,2},
				{0,0,4,4,4,4,4,0,0},
				{0,2,2,2,2,2,2,2,0},
				{0,0,0,4,4,4,0,0,0},
				{0,0,2,2,2,2,2,0,0},
				{0,0,0,0,4,0,0,0,0},
				{0,0,0,2,2,2,0,0,0},
				{0,0,0,0,2,0,0,0,0}
				};
				int PosX = x - 4;  //spawnX and spawnY is where you want the anchor to be when this generates
				int PosY = y - 1;
				if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5))
				{
					return false;
				}
				//i = vertical, j = horizontal
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										break;
									case 1:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, (ushort)mod.TileType("SkyChainTile"), true, true, -1, 0);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 4:
										tile.active(true);
										tile.type = (ushort)mod.TileType("DullPlatingTile");
										tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
			}
			if (type == 7)
			{
				int[,] _structure = {
				{0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0},
				{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2},
				{0,4,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,4,0},
				{0,0,2,0,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,0,2,0,0},
				{0,0,0,0,2,0,0,0,2,2,0,0,0,0,4,4,4,0,0,0,0,2,2,0,0,0,2,0,0,0,0},
				{0,0,0,0,0,0,0,2,2,0,0,0,2,2,2,4,2,2,2,0,0,0,2,2,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,2,2,0,0,0,2,2,0,0,4,0,0,2,2,0,0,0,2,2,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,4,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
				};
				int PosX = x - 15; //spawnX and spawnY is where you want the anchor to be when this generates
				int PosY = y - 1;
				if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5))
				{
					return false;
				}
				//i = vertical, j = horizontal
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										break;
									case 1:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, (ushort)mod.TileType("SkyChainTile"), true, true, -1, 0);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 4:
										tile.active(true);
										tile.type = (ushort)mod.TileType("DullPlatingTile");
										tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				int[,] _structure2 = {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
				{0,0,0,0,0,1,1,1,0,0,1,1,1,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,0,0,0},
				{0,0,0,0,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,0,1,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
				};
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure2.GetLength(0); i++)
				{
					for (int j = _structure2.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure2[i, j])
							{
								case 0:
									break;
								case 1:
									tile.wall = (ushort)mod.WallType("PortalPlatingWallWall");
									break;
							}
						}
					}
				}

			}
			if (type == 8)
			{
				int[,] _structure = {
				{0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{1,1,1,1,0,0,0,1,1,1,2,1,1,1,0,0,0,1,1,1,1},
				{3,3,3,3,0,0,0,3,3,3,3,3,3,3,0,0,0,3,3,3,3},
				{3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3},
				{0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0},
				{0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0},
				{0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0},
				{0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0},
				{0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0},
				{0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0},
				{0,0,3,3,3,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0},
				{0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0},
				{0,0,0,3,3,3,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0},
				{0,0,0,3,3,3,3,1,1,1,1,1,1,1,3,3,3,3,0,0,0},
				{0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0},
				{0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0},
				{0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0},
				{0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0},
				{0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,3,3,3,3,3,3,3,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,3,3,3,3,3,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0}
				};
				int PosX = x - 10; //spawnX and spawnY is where you want the anchor to be when this generates
				int PosY = y - 6;
				if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5))
				{
					return false;
				}
				//i = vertical, j = horizontal
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										break;
									case 1:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = (ushort)mod.TileType("DullPlatingTile");
										tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				int[,] _structure2 = {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,1,2,2,2,2,2,1,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,1,2,3,3,3,2,1,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,1,2,3,3,3,2,1,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,1,2,3,3,3,2,1,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,1,2,2,2,2,2,1,0,0,0,0,0,0,0},
				{0,0,0,0,1,1,1,1,0,0,2,2,0,1,1,1,1,0,0,0,0},
				{0,0,0,0,2,2,2,1,0,0,0,0,0,1,2,2,2,0,0,0,0},
				{0,0,0,0,2,2,2,1,1,1,1,1,1,1,2,2,2,0,0,0,0},
				{0,0,0,0,2,2,2,1,2,2,2,2,2,1,2,2,2,0,0,0,0},
				{0,0,0,0,2,2,2,1,2,3,3,3,2,1,2,2,2,0,0,0,0},
				{0,0,0,0,2,2,2,1,2,3,3,3,2,1,2,2,2,0,0,0,0},
				{0,0,0,0,2,2,2,1,2,3,3,3,2,1,2,2,2,0,0,0,0},
				{0,0,0,0,2,2,2,1,2,3,3,3,2,1,2,2,2,0,0,0,0},
				{0,0,0,0,2,2,2,1,2,3,3,3,2,1,2,2,2,0,0,0,0},
				{0,0,0,0,2,2,2,1,2,3,3,3,2,1,2,2,2,0,0,0,0},
				{0,0,0,0,2,2,2,1,2,3,3,3,2,1,2,2,2,0,0,0,0},
				{0,0,0,0,2,2,2,1,2,2,2,2,2,1,2,2,2,0,0,0,0},
				{0,0,0,0,0,2,2,1,1,1,1,1,1,1,0,0,0,0,0,0,0},
				{0,0,0,0,0,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
				};
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure2.GetLength(0); i++)
				{
					for (int j = _structure2.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure2[i, j])
							{
								case 0:
									break;
								case 1:
									tile.wall = (ushort)mod.WallType("PortalPlatingWallWall");
									break;
								case 2:
									tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
									break;
								case 3:
									tile.wall = (ushort)ModContent.WallType<HologlassWallWall>();
									break;
							}
						}
					}
				}
			}
			if (type == 9)
			{
				int[,] _structure = {
				{0,0,1,1,1,1,1,1,1,0,0},
				{0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0},
				{1,1,1,1,1,2,1,1,1,1,1},
				{0,3,3,3,3,3,3,3,3,3,0},
				{0,0,3,3,3,3,3,3,3,0,0},
				{0,0,0,3,3,3,3,3,0,0,0},
				{0,0,0,0,3,3,3,0,0,0,0},
				{0,0,0,0,0,3,0,0,0,0,0}
				};
				int PosX = x - 5;  //spawnX and spawnY is where you want the anchor to be when this generates
				int PosY = y - 6;
				if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5))
				{
					return false;
				}
				//i = vertical, j = horizontal
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										break;
									case 1:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = (ushort)mod.TileType("AvaritianPlatingTile");
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = (ushort)mod.TileType("DullPlatingTile");
										tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				int[,] _structure2 = {
				{0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,1,2,2,2,1,0,0,0},
				{0,0,0,1,2,3,2,1,0,0,0},
				{0,0,0,1,2,3,2,1,0,0,0},
				{0,0,0,1,2,3,2,1,0,0,0},
				{0,0,0,1,2,2,2,1,0,0,0},
				{0,0,0,0,0,2,2,0,0,0,0},
				{0,2,2,2,2,2,2,2,2,2,0},
				{0,0,2,2,2,2,2,2,2,0,0},
				{0,0,0,2,2,2,2,2,0,0,0},
				{0,0,0,0,2,2,2,0,0,0,0},
				{0,0,0,0,0,2,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0}
				};
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure2.GetLength(0); i++)
				{
					for (int j = _structure2.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure2[i, j])
							{
								case 0:
									break;
								case 1:
									tile.wall = (ushort)mod.WallType("PortalPlatingWallWall");
									break;
								case 2:
									tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
									break;
								case 3:
									tile.wall = (ushort)ModContent.WallType<HologlassWallWall>();
									break;
							}
						}
					}
				}
			}

			return true;
		}
		public static bool GenerateBiomeChestIslands(int x, int y, int type, Mod mod, bool residual = false)
		{
			if (residual == true)
			{
				ushort firstUniqueTile = 0;
				ushort secondUniqueTile = 0;
				if (type == 0)
				{
					firstUniqueTile = TileID.CrimtaneBrick;
					secondUniqueTile = (ushort)ModContent.TileType<DullPlatingTile>();
				}
				if (type == 1)
				{
					firstUniqueTile = TileID.DemoniteBrick;
					secondUniqueTile = (ushort)ModContent.TileType<DullPlatingTile>();
				}
				if (type == 2)
				{
					firstUniqueTile = TileID.GoldBrick;
					secondUniqueTile = TileID.CobaltBrick;
				}
				if (type == 3)
				{
					firstUniqueTile = TileID.JungleGrass;
					secondUniqueTile = TileID.Mudstone;
				}
				if (type == 4)
				{
					firstUniqueTile = TileID.IceBrick;
					secondUniqueTile = TileID.SnowBrick;
				}
				int[,] _structure = {
					{0,0,0,1,0,0,0,0,0,1,0,0,0},
					{2,2,3,3,3,2,2,2,3,3,3,2,2},
					{0,5,5,6,6,6,2,6,6,6,5,5,0},
					{0,0,5,5,6,6,2,6,6,5,5,0,0},
					{0,2,2,2,2,2,2,2,2,2,2,2,0},
					{0,0,0,5,5,6,2,6,5,5,0,0,0},
					{0,0,0,0,5,5,2,5,5,0,0,0,0},
					{0,0,0,0,0,5,2,5,0,0,0,0,0},
					{0,0,0,0,0,0,2,0,0,0,0,0,0},
					{0,0,0,0,0,0,2,0,0,0,0,0,0}
				};
				int PosX = x - 6;  //spawnX and spawnY is where you want the anchor to be when this generates
				int PosY = y - 1;
				if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5))
				{
					return false;
				}
				//i = vertical, j = horizontal
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 1:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, ModContent.TileType<SkyChainTile>(), true, true, -1, 0);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = firstUniqueTile;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = (ushort)ModContent.TileType<AvaritianPlatingTile>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 5:
										tile.active(true);
										tile.type = secondUniqueTile;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 6:
										tile.active(true);
										tile.type = (ushort)ModContent.TileType<DullPlatingTile>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				return true;
			}
			if (type == 0)
			{
				int[,] _structure = {
				{0,0,0,1,1,1,1,1,1,1,1,0,0,0},
				{0,0,1,2,2,2,2,2,2,2,2,1,0,0},
				{0,0,1,2,1,1,1,1,1,1,2,1,0,0},
				{0,1,1,1,1,0,0,0,0,1,1,1,1,0},
				{0,0,1,0,0,0,0,0,0,0,0,1,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,1,4,0,0,0,3,0,0,0,0,4,1,0},
				{2,1,1,1,4,4,1,1,4,4,1,1,1,2},
				{2,2,2,2,1,1,1,1,1,1,2,2,2,2},
				{0,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,0,0,2,2,2,2,2,2,2,2,0,0,0},
				{0,0,0,0,2,2,2,2,2,2,0,0,0,0},
				{0,0,0,0,0,2,2,2,2,0,0,0,0,0},
				{0,0,0,0,0,0,2,2,0,0,0,0,0,0},
				{0,0,0,0,0,0,2,2,0,0,0,0,0,0}
				};
				int PosX = x - 6;  //spawnX and spawnY is where you want the anchor to be when this generates
				int PosY = y - 10;

				if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5))
				{
					return false;
				}
				//i = vertical, j = horizontal
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 1:
										tile.active(true);
										tile.type = 347;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = (ushort)ModContent.TileType<DullPlatingTile>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 21, true, true, -1, 25);
										}
										break;
									case 4:
										tile.active(true);
										tile.type = 347;
										tile.slope(0);
										tile.halfBrick(true);
										break;
								}
							}
						}
					}
				}
				_structure = new int[,] {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,1,1,1,1,1,1,0,0,0,0},
				{0,0,0,2,1,1,1,1,1,1,2,0,0,0},
				{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
				{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
				{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
				{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
				{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0}
				};
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.wall = 0;
									break;
								case 1:
									tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
									break;
								case 2:
									tile.wall = 174;
									break;
								case 3:
									tile.wall = 92;
									break;
							}
						}
					}
				}
			}
			if (type == 1)
			{
				int[,] _structure = {
					{0,0,0,1,1,1,1,1,1,1,1,0,0,0},
					{0,0,1,2,2,2,2,2,2,2,2,1,0,0},
					{0,0,1,2,1,1,1,1,1,1,2,1,0,0},
					{0,1,1,1,1,0,0,0,0,1,1,1,1,0},
					{0,0,1,0,0,0,0,0,0,0,0,1,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,1,4,0,0,0,3,0,0,0,0,4,1,0},
					{2,1,1,1,4,4,1,1,4,4,1,1,1,2},
					{2,2,2,2,1,1,1,1,1,1,2,2,2,2},
					{0,6,6,2,2,2,2,2,2,2,2,6,6,0},
					{0,0,0,6,6,6,6,6,6,6,6,0,0,0},
					{0,0,0,0,6,6,6,6,6,6,0,0,0,0},
					{0,0,0,0,0,6,6,6,6,0,0,0,0,0},
					{0,0,0,0,0,0,6,6,0,0,0,0,0,0},
					{0,0,0,0,0,0,6,6,0,0,0,0,0,0}
				};
				int PosX = x - 6;  //spawnX and spawnY is where you want the anchor to be when this generates
				int PosY = y - 10;
				if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5))
				{
					return false;
				}
				//i = vertical, j = horizontal
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 1:
										tile.active(true);
										tile.type = 140;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = 152;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 21, true, true, -1, 24);
										}
										break;
									case 4:
										tile.active(true);
										tile.type = 140;
										tile.slope(0);
										tile.halfBrick(true);
										break;
									case 6:
										tile.active(true);
										tile.type = (ushort)ModContent.TileType<DullPlatingTile>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				_structure = new int[,] {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,1,1,1,1,0,0,0,0,0},
					{0,0,0,2,1,1,1,1,1,1,2,0,0,0},
					{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
					{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
					{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
					{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
					{0,0,0,0,1,3,3,3,3,1,2,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0}
				};
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.wall = 0;
									break;
								case 1:
									tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
									break;
								case 2:
									tile.wall = 33;
									break;
								case 3:
									tile.wall = 88;
									break;
							}
						}
					}
				}
			}
			if (type == 2)
			{
				int[,] _structure = {
					{0,0,0,1,1,1,1,1,1,1,1,0,0,0},
					{0,0,1,2,2,2,2,2,2,2,2,1,0,0},
					{0,0,1,2,1,1,1,1,1,1,2,1,0,0},
					{0,1,1,1,1,0,0,0,0,1,1,1,1,0},
					{0,0,1,0,0,0,0,0,0,0,0,1,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,1,4,0,0,0,3,0,0,0,0,4,1,0},
					{2,1,1,1,4,4,1,1,4,4,1,1,1,2},
					{2,2,2,2,1,1,1,1,1,1,2,2,2,2},
					{0,6,6,2,2,2,2,2,2,2,2,6,6,0},
					{0,0,0,7,7,7,6,7,7,7,7,0,0,0},
					{0,0,0,0,6,6,6,6,6,6,0,0,0,0},
					{0,0,0,0,0,7,6,7,7,0,0,0,0,0},
					{0,0,0,0,0,0,6,7,0,0,0,0,0,0},
					{0,0,0,0,0,0,6,7,0,0,0,0,0,0}
				};
				int PosX = x - 6;  //spawnX and spawnY is where you want the anchor to be when this generates
				int PosY = y - 10;
				if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5))
				{
					return false;
				}
				//i = vertical, j = horizontal
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 1:
										tile.active(true);
										tile.type = 45;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = 121;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 21, true, true, -1, 26);
										}
										break;
									case 4:
										tile.active(true);
										tile.type = 45;
										tile.slope(0);
										tile.halfBrick(true);
										break;
									case 6:
										tile.active(true);
										tile.type = (ushort)ModContent.TileType<AvaritianPlatingTile>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 7:
										tile.active(true);
										tile.type = (ushort)ModContent.TileType<DullPlatingTile>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				_structure = new int[,] {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,1,1,1,1,0,0,0,0,0},
					{0,0,0,2,1,1,1,1,1,1,2,0,0,0},
					{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
					{0,0,0,2,1,3,4,4,3,1,2,0,0,0},
					{0,0,0,2,1,3,4,4,3,1,2,0,0,0},
					{0,0,0,2,1,3,4,4,3,1,2,0,0,0},
					{0,0,0,2,1,3,4,4,3,1,2,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0}
				};
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.wall = 0;
									break;
								case 1:
									tile.wall = (ushort)ModContent.WallType<AvaritianPlatingWallWall>();
									break;
								case 2:
									tile.wall = 10;
									break;
								case 3:
									tile.wall = 89;
									break;
								case 4:
									tile.wall = 93;
									break;
							}
						}
					}
				}
			}
			if (type == 3)
			{
				int[,] _structure = {
					{0,0,0,1,1,1,1,1,1,1,1,0,0,0},
					{0,0,1,1,2,2,2,2,2,2,1,1,0,0},
					{0,0,1,2,1,1,1,1,1,1,2,1,0,0},
					{0,1,1,1,1,0,0,3,0,1,1,1,1,0},
					{0,0,1,0,0,0,0,0,0,0,0,1,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,1,5,0,0,0,4,0,0,0,0,5,1,0},
					{2,1,1,1,5,5,1,1,5,5,1,1,1,2},
					{2,2,2,2,1,1,1,1,1,1,2,2,2,2},
					{0,7,7,2,2,2,2,2,2,2,2,7,7,0},
					{0,0,0,7,7,7,7,7,7,7,7,0,0,0},
					{0,0,0,0,7,7,7,7,7,7,0,0,0,0},
					{0,0,0,0,0,7,7,7,7,0,0,0,0,0},
					{0,0,0,0,0,0,7,7,0,0,0,0,0,0},
					{0,0,0,0,0,0,7,7,0,0,0,0,0,0}
				};
				int PosX = x - 6;  //spawnX and spawnY is where you want the anchor to be when this generates
				int PosY = y - 10;
				if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5))
				{
					return false;
				}
				//i = vertical, j = horizontal
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 1:
										tile.active(true);
										tile.type = 60;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = 120;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = 62;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 4:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 21, true, true, -1, 23);
										}
										break;
									case 5:
										tile.active(true);
										tile.type = 60;
										tile.slope(0);
										tile.halfBrick(true);
										break;
									case 7:
										tile.active(true);
										tile.type = (ushort)ModContent.TileType<DullPlatingTile>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				_structure = new int[,] {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,1,1,1,1,1,0,0,0,0,0},
					{0,0,0,2,1,1,1,1,1,1,2,0,0,0},
					{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
					{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
					{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
					{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
					{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
					{0,0,0,0,0,0,0,0,0,1,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0}
				};
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.wall = 0;
									break;
								case 1:
									tile.wall = (ushort)ModContent.WallType<AvaritianPlatingWallWall>();
									break;
								case 2:
									tile.wall = 67;
									break;
								case 3:
									tile.wall = 91;
									break;
							}
						}
					}
				}

			}
			if (type == 4)
			{
				int[,] _structure = {
					{0,0,0,1,1,1,1,1,1,1,1,0,0,0},
					{0,0,1,2,2,2,2,2,2,2,2,1,0,0},
					{0,0,1,2,1,1,1,1,1,1,2,1,0,0},
					{0,1,1,1,1,0,0,0,0,1,1,1,1,0},
					{0,0,1,0,0,0,0,0,0,0,0,1,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,1,4,0,0,0,3,0,0,0,0,4,1,0},
					{2,1,1,1,4,4,1,1,4,4,1,1,1,2},
					{2,2,2,2,1,1,1,1,1,1,2,2,2,2},
					{0,6,6,2,2,2,2,2,2,2,2,6,6,0},
					{0,0,0,6,6,6,6,6,6,6,6,0,0,0},
					{0,0,0,0,6,6,6,6,6,6,0,0,0,0},
					{0,0,0,0,0,6,6,6,6,0,0,0,0,0},
					{0,0,0,0,0,0,6,6,0,0,0,0,0,0},
					{0,0,0,0,0,0,6,6,0,0,0,0,0,0}
				};
				int PosX = x - 6;  //spawnX and spawnY is where you want the anchor to be when this generates
				int PosY = y - 10;
				if (!Empty(PosX, PosY, _structure.GetLength(1), _structure.GetLength(0), 5))
				{
					return false;
				}
				//i = vertical, j = horizontal
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 1:
										tile.active(true);
										tile.type = 206;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = 148;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 21, true, true, -1, 27);
										}
										break;
									case 4:
										tile.active(true);
										tile.type = 206;
										tile.slope(0);
										tile.halfBrick(true);
										break;
									case 6:
										tile.active(true);
										tile.type = (ushort)ModContent.TileType<DullPlatingTile>();
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				_structure = new int[,] {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,1,1,1,1,1,1,0,0,0,0},
					{0,0,0,2,1,1,1,1,1,1,2,0,0,0},
					{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
					{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
					{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
					{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
					{0,0,0,2,1,3,3,3,3,1,2,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0}
				};
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.wall = 0;
									break;
								case 1:
									tile.wall = (ushort)ModContent.WallType<AvaritianPlatingWallWall>();
									break;
								case 2:
									tile.wall = 84;
									break;
								case 3:
									tile.wall = 90;
									break;
							}
						}
					}
				}
			}
			if (!residual)
			{
				int direction = Main.rand.Next(2) * 2 - 1;
				int directionV = Main.rand.Next(2) * 2 - 1;
				Vector2 tileLocation = new Vector2(x, y);
				for (int r = 0; r < 4; r++)
				{
					if (r == 1)
					{
						direction *= -1;
						directionV *= -1;
					}
					tileLocation = new Vector2(x, y);
					tileLocation.X += direction * (10 + Main.rand.Next(45));
					tileLocation.Y += directionV * Main.rand.Next(80);

					int extend = 0;
					while (!GenerateBiomeChestIslands((int)tileLocation.X, (int)tileLocation.Y, type, mod, true))
					{
						tileLocation = new Vector2(x, y);
						tileLocation.X += direction * (10 + Main.rand.Next(45 + extend));
						tileLocation.Y += directionV * (Main.rand.Next(80));
						extend += 2;
					}
				}
			}
			return true;
		}
		public static bool SkytileValid(Tile tile, Mod mod)
		{
			return tile.active() && (tile.type == (ushort)ModContent.TileType<DullPlatingTile>() || tile.type == (ushort)ModContent.TileType<AvaritianPlatingTile>());
		}
		public static void DistributeSkyThings(Mod mod, int maxChests = 30, int maxDisplays = 7, int maxPotGens = 5, int maxFabricators = 3, int ratePots = 5, int rateDecor = 45)
		{
			int next = 0;
			int totalChests = 0;
			int totalDisplays = 0;
			int totalPotGens = 0;
			int totalFabricators = 0;
			for (int i = 20; i < Main.maxTilesX - 20; i++)
			{
				for (int j = Main.maxTilesY - 20; j > 20; j--)
				{
					Tile tile = Framing.GetTileSafely(i, j);
					Tile tile2 = Framing.GetTileSafely(i + 1, j);
					Tile tile3 = Framing.GetTileSafely(i + 2, j);
					if (SkytileValid(tile, mod) && WorldGen.InWorld(i, j, 20))
					{
						if (Main.rand.Next(ratePots) == 0 && Empty(i, j - 2, 2, 2) && SkytileValid(tile2, mod))
						{
							WorldGen.PlaceTile(i, j - 1, (ushort)ModContent.TileType<SkyPots>(), true, true, -1, Main.rand.Next(9)); //pots
						}
						else if (Main.rand.Next(rateDecor) == 0 && Empty(i - 1, j - 2, 3, 2))
						{
							tile2 = Framing.GetTileSafely(i - 2, j);
							tile3 = Framing.GetTileSafely(i + 2, j);
							WorldGen.PlaceTile(i, j - 1, (ushort)ModContent.TileType<HardlightTableTile>(), true, true, -1, 0);
							if (Main.rand.Next(2) == 0 && SkytileValid(tile2, mod) && Empty(i - 2, j - 2, 1, 2))
							{
								WorldGen.PlaceTile(i - 2, j - 1, (ushort)ModContent.TileType<HardlightChairTile>(), true, true, -1, 1);
							}
							if (Main.rand.Next(2) == 0 && SkytileValid(tile2, mod) && Empty(i + 2, j - 2, 1, 2))
							{
								WorldGen.PlaceTile(i + 2, j - 1, (ushort)ModContent.TileType<HardlightChairTile>(), true, true, -1, 0);
							}
						}
					}
				}
			}
			while (totalChests < maxChests)
			{
				int i = Main.rand.Next(15, Main.maxTilesX - 15);
				int j = Main.rand.Next(15, Main.maxTilesY - 15);
				Tile tile = Framing.GetTileSafely(i, j);
				Tile tile2 = Framing.GetTileSafely(i + 1, j);
				Tile tile3 = Framing.GetTileSafely(i + 2, j);
				if (SkytileValid(tile, mod) && WorldGen.InWorld(i, j, 20))
				{
					if (Empty(i, j - 2, 2, 2) && SkytileValid(tile2, mod))
					{
						if (next % 3 == 0)
						{
							WorldGen.PlaceChest(i, j - 1, (ushort)ModContent.TileType<LockedSkywareChest>(), style: 1);
							tile.type = TileID.Sunplate;
							tile2.type = TileID.Sunplate;
						}
						if (next % 3 == 1)
						{
							WorldGen.PlaceChest(i, j - 1, (ushort)ModContent.TileType<LockedMeteoriteChest>(), style: 1);
							tile.type = TileID.MeteoriteBrick;
							tile2.type = TileID.MeteoriteBrick;
						}
						if (next % 3 == 2)
						{
							WorldGen.PlaceChest(i, j - 1, (ushort)ModContent.TileType<LockedStrangeChest>(), style: 1);
							tile.type = (ushort)ModContent.TileType<AvaritianPlatingTile>();
							tile2.type = (ushort)ModContent.TileType<AvaritianPlatingTile>();
						}
						totalChests++;
						next++;
					}
				}
			}
			while (totalDisplays < maxDisplays)
			{
				int i = Main.rand.Next(15, Main.maxTilesX - 15);
				int j = Main.rand.Next(15, Main.maxTilesY - 15);
				Tile tile = Framing.GetTileSafely(i, j);
				Tile tile2 = Framing.GetTileSafely(i + 1, j);
				Tile tile3 = Framing.GetTileSafely(i - 1, j);
				if (SkytileValid(tile, mod) && WorldGen.InWorld(i, j, 20))
				{
					if (SkytileValid(tile2, mod) && SkytileValid(tile3, mod) && Empty(i - 1, j - 3, 3, 2))
					{
						WorldGen.PlaceTile(i, j - 1, (ushort)ModContent.TileType<DigitalDisplayTile>(), true, true, -1, Main.rand.Next(3));
						totalDisplays++;
					}
				}
			}
			while (totalFabricators < maxFabricators)
			{
				int i = Main.rand.Next(15, Main.maxTilesX - 15);
				int j = Main.rand.Next(15, Main.maxTilesY - 15);
				Tile tile = Framing.GetTileSafely(i, j);
				Tile tile2 = Framing.GetTileSafely(i + 1, j);
				Tile tile3 = Framing.GetTileSafely(i - 1, j);
				if (SkytileValid(tile, mod) && WorldGen.InWorld(i, j, 20))
				{
					if (SkytileValid(tile2, mod) && SkytileValid(tile3, mod) && Empty(i - 1, j - 3, 3, 2))
					{
						WorldGen.PlaceTile(i, j - 1, (ushort)ModContent.TileType<HardlightFabricatorTile>(), true, true, -1, 0);
						totalFabricators++;
					}
				}
			}
			while (totalPotGens < maxPotGens)
			{
				int i = Main.rand.Next(15, Main.maxTilesX - 15);
				int j = Main.rand.Next(15, Main.maxTilesY - 15);
				Tile tile = Framing.GetTileSafely(i, j);
				Tile tile2 = Framing.GetTileSafely(i + 1, j);
				Tile tile3 = Framing.GetTileSafely(i, j + 1);
				Tile tile4 = Framing.GetTileSafely(i + 1, j + 1);
				if (SkytileValid(tile, mod))
				{
					if (SkytileValid(tile2, mod) && SkytileValid(tile3, mod) && SkytileValid(tile4, mod) && Empty(i, j - 2, 2, 2))
					{
						tile.active(false);
						tile2.active(false);
						ModTileEntity modTileEntity = ModTileEntity.GetTileEntity(ModContent.TileEntityType<PotTimer>());
						WorldGen.PlaceTile(i, j, (ushort)ModContent.TileType<PotGeneratorTile>(), true, true, -1, 0);
						modTileEntity.Place(i, j);
						tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
						tile2.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
						totalPotGens++;
					}
				}
			}
		}
		public static bool GeneratePlanetariumFull(Mod mod, int i, int j, bool force = false)
		{
			Vector2 tileLocation = new Vector2(i, j);
			if (!SOTSWorldgenHelper.GenerateSkyArtifact((int)tileLocation.X, (int)tileLocation.Y, mod, force))
			{
				return false;
			}
			for (int r = 0; r < 30; r++)
			{
				tileLocation = new Vector2(i, j);
				if (Main.rand.Next(2) == 0)
				{
					tileLocation.X += Main.rand.Next(300);
				}
				else
				{
					tileLocation.X -= Main.rand.Next(300);
				}

				if (Main.rand.Next(2) == 0)
				{
					tileLocation.Y += Main.rand.Next(50);
				}
				else
				{
					tileLocation.Y -= Main.rand.Next(36) + 50;
				}

				int extend = 0;
				while (!SOTSWorldgenHelper.GenerateArtifactIslands((int)tileLocation.X, (int)tileLocation.Y, r % 10, mod))
				{
					tileLocation = new Vector2(i, j);
					if (Main.rand.Next(2) == 0)
					{
						tileLocation.X += Main.rand.Next(300 + extend);
					}
					else
					{
						tileLocation.X -= Main.rand.Next(300 + extend);
					}

					if (Main.rand.Next(2) == 0)
					{
						tileLocation.Y += Main.rand.Next(50);
					}
					else
					{
						tileLocation.Y -= Main.rand.Next(36) + 50;
					}

					extend++;
				}
			}
			int direction = Main.rand.Next(2) * 2 - 1;
			for (int r = 0; r < 2; r++)
			{
				int type = 2;
				if (r == 1)
				{
					direction *= -1;
					type = 4;
				}
				tileLocation = new Vector2(i, j);
				tileLocation.X += direction * (150 + Main.rand.Next(240));
				tileLocation.Y += Main.rand.Next(50);

				int extend = 0;
				while (!GenerateBiomeChestIslands((int)tileLocation.X, (int)tileLocation.Y, type, mod))
				{
					tileLocation = new Vector2(i, j);
					tileLocation.X += direction * (150 + Main.rand.Next(240));
					tileLocation.Y += Main.rand.Next(50);
					extend++;
				}
			}
			SOTSWorldgenHelper.DistributeSkyThings(mod, 30, 7, 10, 4, 5, 45);
			return true;
		}
		public static void GenerateCoconutIsland(Mod mod, int x, int y, int direction = 1)
		{
			if (direction != 1 && direction != -1)
			{
				return;
			}
			int[,] _structure = {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,2,2,2,2,2,4,0,0,5,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,2,2,2,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,3,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,3,2,2,2,7,2,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,6,0,0,2,2,2,7,11,11,2,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,6,0,12,12,12,12,12,12,2,2,7,11,11,11,11,11,11,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0},
				{0,0,12,12,12,12,12,12,12,12,12,12,2,11,7,7,11,11,11,11,11,11,14,0,9,0,0,0,0,0,0,0,0,0,12,12,12,12,12,0,6,0,0,0,0},
				{15,12,12,12,12,12,12,12,12,12,12,2,2,11,11,7,11,7,11,11,11,11,11,11,11,11,11,13,0,0,0,0,12,12,12,12,12,12,12,12,12,12,0,0,15},
				{15,15,12,12,12,12,12,12,12,12,2,2,2,2,2,11,11,7,7,7,11,11,16,11,11,11,11,11,11,11,7,7,12,12,12,12,12,12,12,12,17,17,17,17,15},
				{0,15,17,12,12,12,12,12,2,2,2,2,2,2,2,2,11,7,7,11,7,11,11,11,11,11,7,7,7,7,7,12,12,12,12,12,12,12,17,17,17,15,15,15,19},
				{0,15,15,17,17,12,12,12,12,12,12,2,2,2,7,7,7,7,11,7,7,11,11,11,7,7,7,7,12,12,12,12,12,12,12,12,17,17,17,17,15,15,19,0,0},
				{0,0,15,15,17,17,17,12,12,12,2,2,2,2,2,2,2,7,7,7,7,11,11,11,7,7,7,12,12,12,12,12,12,12,12,17,17,17,17,15,15,19,0,0,0},
				{0,0,0,15,15,15,17,17,12,12,12,12,12,2,2,2,2,7,2,7,11,11,11,7,7,12,12,12,12,12,12,12,12,12,17,17,17,15,15,15,0,0,0,0,0},
				{0,0,0,0,0,15,15,15,17,12,12,12,12,12,12,2,2,7,2,7,11,11,7,7,12,12,12,12,12,12,12,12,12,17,17,15,15,15,0,0,0,0,0,0,0},
				{0,0,0,0,0,20,15,15,15,17,12,12,12,2,2,2,2,2,2,7,11,7,7,12,12,12,12,12,12,12,12,12,17,17,15,15,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,15,15,15,17,12,12,12,12,2,2,2,2,7,2,7,2,12,12,12,12,12,12,12,12,12,17,15,15,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,20,15,17,17,17,17,12,12,12,2,2,2,2,7,2,2,12,12,12,12,12,12,17,17,15,15,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,15,15,17,17,17,17,17,12,12,12,12,2,2,2,2,12,12,12,12,12,17,15,15,15,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,15,15,15,15,17,17,17,17,17,2,2,2,2,2,2,12,15,17,17,15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,20,15,15,15,15,17,17,2,2,2,2,2,2,15,15,15,15,15,19,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,15,15,17,17,17,15,2,2,2,2,2,15,15,0,0,0,0,21,0,3,2,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,17,10,10,2,2,2,2,2,2,8,0,0,1,2,2,2,2,4,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,22,10,2,2,2,2,2,2,2,1,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,2,2,2,2,23,23,2,2,2,2,2,2,2,2,2,2,2,2,2,4,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,2,2,2,2,2,12,17,2,2,2,2,2,2,4,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,12,17,15,15,0,5,2,2,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,2,2,12,12,17,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,12,17,17,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,12,17,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,2,12,17,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,17,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,17,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,17,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,17,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
			};
			int PosX = x - 22 * direction; //spawnX and spawnY is where you want the anchor to be when this generates
			int PosY = y - 14;
			//i = vertical, j = horizontal
			for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
			{
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j * direction;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									break;
								case 1:
									tile.active(true);
									tile.type = 1;
									tile.slope(0);
									tile.halfBrick(true);
									tile.wall = (ushort)WallID.Stone;
									break;
								case 2:
									tile.active(true);
									tile.type = 1;
									tile.slope(0);
									tile.halfBrick(false);
									tile.wall = (ushort)WallID.Stone;
									break;
								case 3:
									tile.active(true);
									tile.type = 1;
									tile.slope((byte)(direction == 1 ? 2 : 1));
									tile.halfBrick(false);
									tile.wall = (ushort)WallID.Stone;
									break;
								case 4:
									tile.active(true);
									tile.type = 1;
									tile.slope((byte)(direction == 1 ? 3 : 4));
									tile.halfBrick(false);
									tile.wall = (ushort)WallID.Stone;
									break;
								case 5:
									tile.active(true);
									tile.type = 1;
									tile.slope((byte)(direction == 1 ? 4 : 3));
									tile.halfBrick(false);
									tile.wall = (ushort)WallID.Stone;
									break;
								case 6:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 20, true, true, -1, 18);
										WorldGen.GrowPalmTree(k, l);
									}
									break;
								case 7:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<PyramidSlabTile>();
									tile.slope(0);
									tile.halfBrick(false);
									tile.wall = (ushort)WallID.SandstoneBrick;
									break;
								case 8:
									tile.active(true);
									tile.type = 1;
									tile.slope((byte)(direction == 1 ? 1 : 2));
									tile.halfBrick(false);
									break;
								case 9:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<StrangeKeystoneTile>(), true, true, -1, 0);
									}
									break;
								case 10:
									tile.wall = (ushort)WallID.SandstoneBrick;
									break;
								case 11:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<OvergrownPyramidTileSafe>();
									tile.slope(0);
									tile.halfBrick(false);
									tile.wall = (ushort)WallID.GrassUnsafe;
									break;
								case 12:
									tile.active(true);
									tile.type = 53;
									tile.slope(0);
									tile.halfBrick(false);
									tile.wall = (ushort)WallID.Sandstone;
									break;
								case 13:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<OvergrownPyramidTileSafe>();
									tile.slope(0);
									tile.halfBrick(true);
									tile.wall = (ushort)WallID.GrassUnsafe;
									break;
								case 14:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<OvergrownPyramidTileSafe>();
									tile.slope((byte)(direction == 1 ? 1 : 2));
									tile.halfBrick(false);
									tile.wall = (ushort)WallID.GrassUnsafe;
									break;
								case 15:
									tile.active(true);
									tile.type = 396;
									tile.slope(0);
									tile.halfBrick(false);
									tile.wall = (ushort)WallID.Sandstone;
									break;
								case 16:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<OvergrownPyramidTileSafe>();
									tile.slope(0);
									tile.halfBrick(false);
									tile.wall = (ushort)WallID.GrassUnsafe;
									break;
								case 17:
									tile.active(true);
									tile.type = 397;
									tile.slope(0);
									tile.halfBrick(false);
									tile.wall = (ushort)WallID.Sandstone;
									break;
								case 19:
									tile.active(true);
									tile.type = 396;
									tile.slope((byte)(direction == 1 ? 3 : 4));
									tile.halfBrick(false);
									tile.wall = (ushort)WallID.Sandstone;
									break;
								case 20:
									tile.active(true);
									tile.type = 396;
									tile.slope((byte)(direction == 1 ? 4 : 3));
									tile.halfBrick(false);
									tile.wall = (ushort)WallID.Sandstone;
									break;
								case 21:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k - (direction != 1 ? 1 : 0), l, 376, true, true, -1, 0);
									}
									break;
								case 22:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k - (direction != 1 ? 1 : 0), l, 21, true, true, -1, 31);
										tile.wall = (ushort)WallID.SandstoneBrick;
									}
									break;
								case 23:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<PyramidBrickTile>();
									tile.slope(0);
									tile.halfBrick(false);
									break;
							}
						}
					}
				}
			}
		}
		public static void GenerateStarterHouseFull(Mod mod, int type)
		{
			int spawnX = -1;
			int spawnY = -1;
			int randomOne = Main.rand.Next(2) * 2 - 1;
			int randAttempt = randomOne * Main.rand.Next(40, 81);
			for (int xCheck = Main.maxTilesX / 2 + randAttempt; ; xCheck = Main.maxTilesX / 2 + randAttempt)
			{
				randAttempt = randomOne * Main.rand.Next(40, 81);
				for (int ydown = 0; ; ydown++)
				{
					Tile tile = Framing.GetTileSafely(xCheck, ydown);
					if (tile.active() && Main.tileSolid[tile.type])
					{
						spawnY = ydown;
						break;
					}
				}
				if (spawnY != -1)
				{
					spawnX = xCheck;
					break;
				}
			}
			GenerateStarterHouse(mod, spawnX, spawnY, type);
		}
		public static void UseStarterHouseHalfCircle(int spawnX, int spawnY, int side = 0, int radius = 10, int radiusY = 10)
		{
			radius += 2;
			radiusY++;
			float scale = radiusY / (float)radius;
			float invertScale = (float)radius / radiusY;
			if (side == 0)
			{
				for (int x = -radius; x <= radius; x++)
				{
					for (float y = -radius - 1; y <= 0; y += invertScale)
					{
						int xPosition6 = spawnX + x;
						if (Math.Sqrt(x * x + (int)y * (int)y) <= radius + 0.5)
						{
							WorldGen.KillTile(xPosition6, spawnY + (int)(y * scale + 0.5f), false, false, false);
						}
					}
				}
			}
			else if (side == 1)
			{
				for (int x = -radius; x <= radius; x++)
				{
					for (float y = -1; y <= radius; y += invertScale)
					{
						if (Math.Sqrt(x * x + y * y) <= radius + 0.5)
						{
							int xPosition6 = spawnX + x;
							int yPosition6 = spawnY + (int)(y * scale + 0.5f);
							Tile tile = Framing.GetTileSafely(xPosition6, yPosition6);
							Tile tile2 = Framing.GetTileSafely(xPosition6, yPosition6 - 1);
							if (!tile.active())
							{
								tile.type = TileID.Dirt;
								tile.active(true);
							}
							if (!tile2.active() && tile.type == TileID.Dirt)
							{
								tile.type = 2;
							}
							tile.active();
						}
					}
				}
			}
		}
		public static void GenerateStarterHouse(Mod mod, int spawnX, int spawnY, int type)
		{
			bool waterbolt = Main.rand.NextBool(10);
			if (Main.worldName.Contains("Astro") || Main.worldName.Contains("astro"))
			{
				waterbolt = true;
				type = 10;
			}
			if (Main.worldName.Contains("Mush") || Main.worldName.Contains("mush"))
			{
				waterbolt = true;
				type = 11;
			}
			if (type == 0)
			{
				int[,] _structure = new int[,] {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,1,3,2,3,1,1,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,3,3,2,3,3,1,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,1,1,1,1,2,1,1,1,1,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,4,4,4,4,2,4,4,4,4,0,0,0,0,0,0,0,0},
					{0,0,0,0,1,1,1,1,1,2,1,1,1,1,1,0,0,0,0,0,0,0},
					{0,0,0,0,1,3,3,3,3,2,3,3,3,3,1,0,0,0,0,0,0,0},
					{0,0,0,0,1,3,3,3,3,2,3,3,3,3,1,0,0,0,0,0,0,0},
					{0,0,0,0,1,1,1,1,1,2,1,1,1,1,1,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,4,4,4,4,0},
					{0,0,0,0,5,5,5,5,5,5,5,1,1,5,5,0,4,4,4,4,4,0},
					{0,0,0,0,5,3,3,3,3,3,5,1,1,5,5,0,4,4,4,4,4,0},
					{0,0,0,0,5,3,3,3,3,3,5,1,1,5,5,0,4,4,4,4,4,0},
					{0,0,0,0,5,5,5,5,5,5,5,1,1,5,5,0,4,4,4,4,4,0},
					{0,0,0,0,6,6,6,6,6,6,6,1,1,6,6,0,4,4,4,4,4,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0},
					{7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0}
				};
				int PosX = spawnX - _structure.GetLength(1) / 2;
				int PosY = spawnY - _structure.GetLength(0) + 2;
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.wall = 0;
									break;
								case 1:
									tile.wall = 4;
									break;
								case 2:
									tile.wall = 78;
									break;
								case 3:
									tile.wall = 21;
									break;
								case 4:
									tile.wall = 27;
									break;
								case 5:
									tile.wall = 142;
									break;
								case 6:
									tile.wall = 5;
									break;
							}
						}
					}
				}
				_structure = new int[,] {
					{0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,1,2,2,2,1,1,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,1,1,2,2,3,2,2,1,1,0,0,0,0,0,0,0,0},
					{0,0,0,0,1,1,2,2,3,3,0,2,2,1,1,0,0,0,0,0,0,0},
					{0,0,0,1,1,2,2,3,0,0,14,14,2,2,1,1,0,0,0,0,0,0},
					{0,0,1,1,2,2,3,5,6,7,4,14,8,2,2,1,1,0,0,0,0,0},
					{0,1,1,2,2,9,9,9,9,9,9,9,9,9,2,2,1,1,0,0,0,0},
					{0,0,0,2,2,3,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0},
					{0,0,0,2,3,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0},
					{0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0},
					{0,0,0,10,0,0,0,0,0,0,0,0,0,0,11,10,0,0,0,0,0,0},
					{0,0,0,2,0,12,0,0,0,0,0,0,0,9,9,2,0,1,0,13,0,1},
					{0,0,0,2,1,1,1,1,1,1,1,9,9,1,1,2,1,1,1,1,1,1},
					{0,0,0,2,2,2,2,2,2,2,2,9,9,2,2,2,2,2,2,2,2,2},
					{0,0,0,2,2,0,3,3,0,0,0,9,9,0,2,2,2,3,3,0,2,2},
					{0,0,0,2,15,0,0,0,0,0,0,9,9,0,0,2,3,0,0,0,0,2},
					{0,0,0,2,9,9,0,0,0,0,0,9,9,0,0,2,0,0,16,0,0,2},
					{0,0,0,0,0,0,0,0,0,0,0,9,9,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,9,9,0,0,0,0,0,0,0,0,0},
					{0,0,0,19,0,21,0,0,22,0,23,9,9,0,0,19,0,24,24,24,0,19},
					{0,25,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
					{25,26,26,1,1,1,1,27,27,27,1,1,27,27,27,1,27,27,1,1,27,27},
					{26,26,26,26,1,27,27,27,27,1,1,27,27,27,27,27,27,1,1,27,26,25}
				};
				UseStarterHouseHalfCircle(spawnX, spawnY, 0, _structure.GetLength(1) / 2, _structure.GetLength(0));
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 14:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 1:
										tile.active(true);
										tile.type = 38;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = 30;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = 51;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 4:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, ModContent.TileType<RuinedChestTile>(), true, true, -1, 0);
										}
										break;
									case 5:
									case 6:
									case 8:
										if (confirmPlatforms == 0)
											tile.active(false);
										else if (confirmPlatforms == 1)
										{
											WorldGen.PlaceTile(k, l, TileID.Books, true, true, -1, Main.rand.Next(5));
											tile.slope(0);
											tile.halfBrick(false);
										}
										break;
									case 7:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 33, true, true, -1, 1);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 9:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 19, true, true, -1, 0);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 10:
										tile.active(true);
										tile.type = 54;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 11:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 319, true, true, -1, 0);
										}
										break;
									case 12:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 79, true, true, -1, 0);
										}
										break;
									case 13:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 215, true, true, -1, 0);
										}
										break;
									case 15:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 103, true, true, -1, 2);
										}
										break;
									case 16:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 240, true, true, -1, 20);
										}
										break;
									case 19:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 10, true, true, -1, 0);
										}
										break;
									case 21:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 21, true, true, -1, 5);
										}
										break;
									case 22:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 96, true, true, -1, 0);
										}
										break;
									case 23:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 172, true, true, -1, 0);
										}
										break;
									case 24:
										tile.active(true);
										tile.type = 332;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 25:
										tile.active(true);
										tile.type = 2;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 26:
										tile.active(true);
										tile.type = 0;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 27:
										tile.active(true);
										tile.type = 1;
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				UseStarterHouseHalfCircle(spawnX, spawnY, 1, _structure.GetLength(1) / 2, 8);
			}
			if (type == 1)
			{
				int[,] _structure = {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0},
					{0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0},
					{0,0,0,1,1,0,0,0,2,0,0,1,1,0,0,0},
					{0,0,1,1,0,0,0,0,2,0,0,0,1,0,0,0},
					{0,0,1,0,3,3,0,0,2,0,3,0,1,1,0,0},
					{0,1,1,3,3,3,3,0,2,3,3,3,3,1,1,0},
					{0,0,0,0,0,0,4,4,2,0,0,0,0,0,0,0},
					{5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5},
					{5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5}
				};
				int PosX = spawnX - _structure.GetLength(1) / 2;
				int PosY = spawnY - _structure.GetLength(0) + 2;
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.wall = 0;
									break;
								case 1:
									tile.wall = 60;
									break;
								case 2:
									tile.wall = 78;
									break;
								case 3:
									tile.wall = 66;
									break;
								case 4:
									tile.wall = 1;
									break;
								case 5:
									tile.wall = 2;
									break;
							}
						}
					}
				}
				_structure = new int[,] {
					{0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0},
					{0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0},
					{0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0},
					{0,1,1,1,1,0,0,0,0,0,0,0,2,0,0,0},
					{0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,14,14,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,9,14,0,0,0,0,0,0,3,0,0,0,0},
					{5,6,7,7,7,7,0,4,0,7,7,7,7,7,7,5},
					{8,8,6,7,7,7,7,7,6,6,6,7,7,8,8,8},
					{8,8,8,8,6,6,6,7,7,7,7,8,8,8,8,5}
				};
				//i = vertical, j = horizontal
				UseStarterHouseHalfCircle(spawnX, spawnY, 0, _structure.GetLength(1) / 2, _structure.GetLength(0));
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 14:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 1:
										tile.active(true);
										tile.type = 192;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 42, true, true, -1, 7);
										}
										break;
									case 3:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 105, true, true, -1, 1);
										}
										break;
									case 4:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 215, true, true, -1, 0);
										}
										break;
									case 5:
										tile.active(true);
										tile.type = 2;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 6:
										tile.active(true);
										tile.type = 1;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 7:
										tile.active(true);
										tile.type = 38;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 8:
										tile.active(true);
										tile.type = 0;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 9:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, ModContent.TileType<RuinedChestTile>(), true, true, -1, 0);
										}
										break;
								}
							}
						}
					}
				}
				UseStarterHouseHalfCircle(spawnX, spawnY, 1, _structure.GetLength(1) / 2, 5);
			}
			if (type == 2)
			{
				int[,] _structure = {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0},
					{0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0},
					{0,0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0},
					{0,0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0},
					{0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0},
					{0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0},
					{0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0},
					{0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,0,0},
					{0,0,0,4,4,2,2,4,2,2,4,2,2,4,4,0,0},
					{0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0},
					{0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0},
					{0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5},
					{5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5}
				};
				int PosX = spawnX - _structure.GetLength(1) / 2;
				int PosY = spawnY - _structure.GetLength(0) + 2;
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.wall = 0;
									break;
								case 1:
									tile.wall = 4;
									break;
								case 2:
									tile.wall = 21;
									break;
								case 3:
									tile.wall = 27;
									break;
								case 4:
									tile.wall = 1;
									break;
								case 5:
									tile.wall = 2;
									break;
							}
						}
					}
				}
				_structure = new int[,] {
					{0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0},
					{0,0,0,0,0,1,1,2,0,0,2,1,1,0,0,0,0},
					{0,0,0,0,1,1,2,0,0,0,0,2,1,1,0,0,0},
					{0,0,0,1,1,2,0,0,0,0,0,0,2,1,1,0,0},
					{0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0},
					{0,0,0,0,0,3,0,0,0,0,0,0,3,0,0,0,0},
					{0,0,0,0,0,3,0,0,0,0,0,0,3,0,0,0,0},
					{0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0},
					{0,1,1,1,1,2,4,0,4,0,4,0,2,1,1,1,1},
					{0,2,2,2,2,2,5,5,5,5,5,5,2,2,2,2,2},
					{0,0,2,2,0,0,0,0,0,0,0,0,0,0,2,2,0},
					{6,0,2,0,0,0,0,0,0,0,0,0,0,0,0,2,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,16,16,16,0,16,16,0,0,0,0},
					{0,0,7,0,10,11,16,8,16,0,9,16,12,0,0,7,0},
					{13,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
					{14,14,1,1,15,1,1,15,15,15,15,1,1,1,15,14,14},
					{14,14,14,14,14,14,14,15,1,1,1,1,14,14,14,14,14}
				};
				//i = vertical, j = horizontal
				UseStarterHouseHalfCircle(spawnX, spawnY, 0, _structure.GetLength(1) / 2, _structure.GetLength(0));
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 16:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 1:
										tile.active(true);
										tile.type = 38;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = 30;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = 54;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 4:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 21, true, true, -1, 5);
										}
										break;
									case 5:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 19, true, true, -1, 0);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 6:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 55, true, true, -1, 3);
										}
										break;
									case 7:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 10, true, true, -1, 0);
										}
										break;
									case 8:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, TileID.Furnaces, true, true, -1, 0);
										}
										break;
									case 9:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, ModContent.TileType<RuinedChestTile>(), true, true, -1, 0);
										}
										break;
									case 10:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 239, true, true, -1, 2);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 11:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, TileID.Anvils, true, true, -1, WorldGen.IronTierOre == 6 ? 0 : 1);
										}
										break;
									case 12:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 18, true, true, -1, 0);
										}
										break;
									case 13:
										tile.active(true);
										tile.type = 2;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 14:
										tile.active(true);
										tile.type = 0;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 15:
										tile.active(true);
										tile.type = 1;
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				UseStarterHouseHalfCircle(spawnX, spawnY, 1, _structure.GetLength(1) / 2, 7);
			}
			if (type == 3)
			{
				int[,] _structure = {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,3,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,4,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,4,4,2,2,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,4,2,2,2,4,2,5,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,4,4,2,4,4,4,2,5,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,2,2,2,4,2,2,2,4,2,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,2,2,2,2,2,2,2,2,2,3,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,6,4,4,4,4,4,4,4,6,3,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,6,4,4,4,4,4,4,4,6,3,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,6,4,4,4,4,4,4,4,6,3,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,6,2,2,2,2,2,2,2,6,3,0,0,0,0,7,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,7,7,7,7,7,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,3,2,2,2,2,2,2,2,2,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,3,3,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,3,6,4,4,4,4,4,4,4,6,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,6,4,4,4,4,4,6,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,3,6,4,4,4,4,4,4,4,6,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,6,4,4,4,4,4,6,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,3,6,4,4,4,4,4,4,4,6,3,0,8,8,8,8,8,8,8,8,8,8,8,8,0,3,3,3,3,6,4,4,4,4,4,6,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,7,0,0,0,0,3,6,2,2,2,2,2,2,2,6,3,0,8,8,8,8,8,8,8,8,8,8,8,8,0,3,3,3,3,6,2,2,2,2,2,6,0,0,0,0,7,0,0,0},
					{0,0,0,0,0,0,7,7,7,7,7,3,3,3,3,3,3,3,3,3,3,3,0,9,9,9,9,9,8,9,9,9,9,8,8,0,3,3,3,3,3,3,3,3,3,3,3,7,7,7,7,7,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,5,3,3,3,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,3,2,3,3,3,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,6,4,4,4,4,4,6,3,3,6,4,4,4,4,4,4,4,4,6,3,3,3,3,3,3,6,4,4,4,4,4,6,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,6,4,4,4,4,4,6,3,3,6,4,4,4,4,4,4,4,4,6,3,3,3,3,3,3,6,4,4,4,4,4,6,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,6,2,2,2,2,2,6,3,3,6,2,2,2,2,2,2,2,2,6,3,3,3,3,3,3,6,2,2,2,2,2,6,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,8,3,3,3,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,3,3,3,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,8,3,3,3,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,3,3,3,8,8,8,8,8,8,8,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,0,0,0,0,0,0,0,0,8,8,8,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10}
				};
				int PosX = spawnX - _structure.GetLength(1) / 2;
				int PosY = spawnY - _structure.GetLength(0) + 2;
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.wall = 0;
									break;
								case 1:
									tile.wall = 60;
									break;
								case 2:
									tile.wall = 1;
									break;
								case 3:
									tile.wall = 4;
									break;
								case 4:
									tile.wall = 21;
									break;
								case 5:
									tile.wall = 27;
									break;
								case 6:
									tile.wall = 78;
									break;
								case 7:
									tile.wall = 106;
									break;
								case 8:
									tile.wall = 5;
									break;
								case 9:
									tile.wall = 115;
									break;
								case 10:
									tile.wall = 2;
									break;
							}
						}
					}
				}
				_structure = new int[,]{
					{0,0,0,0,0,0,0,0,0,1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,3,2,2,2,2,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,1,1,0,0,0,0,0,2,2,5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,1,2,2,2,2,4,0,0,0,3,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0},
					{3,2,2,2,2,5,2,0,0,8,5,5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,9,7,7,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,2,2,2,10,5,5,5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,9,11,9,7,7,0,0,0,0,0,0,0,0,0,0},
					{0,0,12,0,13,0,0,0,5,0,0,2,2,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,9,11,0,0,9,7,7,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,5,0,2,2,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,9,11,0,0,0,11,9,7,7,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,10,5,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,9,11,0,0,0,0,11,11,9,7,7,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,10,5,0,0,0,0,0,7,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,9,11,11,0,0,0,0,0,11,11,9,7,7,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,5,14,0,0,0,7,7,7,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,9,11,11,15,15,0,15,15,0,15,0,11,9,7,7,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,10,5,0,8,7,7,9,7,7,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,9,0,0,16,16,16,16,16,16,16,0,0,9,5,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,5,5,7,7,17,11,18,7,7,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,5,7,7,17,0,0,0,18,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,21,7,7,17,11,0,20,0,0,18,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,19,0,0,0,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,7,7,17,11,11,0,0,0,11,11,18,7,7,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,16,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,7,7,17,11,11,0,0,0,0,0,11,11,18,7,7,0,0,0,0,0,0,0,0,0,0,5,9,0,0,0,0,24,0,0,23,0,0,0,22,0,0,0,9,5,0,0},
					{0,0,0,0,0,0,0,0,7,7,9,0,11,15,15,15,0,15,0,15,0,0,9,7,7,0,0,0,0,0,0,0,0,0,5,9,9,16,16,16,9,9,9,9,9,9,9,9,9,9,9,9,5,0,0},
					{0,0,0,0,0,0,0,0,0,5,9,0,0,16,16,16,16,16,16,16,0,0,9,5,0,0,0,0,0,0,0,0,0,0,5,9,0,16,16,16,0,0,11,11,11,11,0,9,5,5,5,5,5,0,0},
					{0,0,0,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,0,0,0,0,0,19,0,16,16,16,0,0,0,0,11,11,11,19,0,0,0,25,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,0,0,0,0,0,19,0,16,16,16,0,0,0,0,0,0,0,7,0,0,0,25,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,0,0,0,0,0,26,0,0,0,0,0,0,19,0,16,16,16,0,0,0,0,0,0,0,0,0,0,0,25,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,2,2,4,0,16,16,1,2,4,0,0,7,0,16,16,16,0,0,0,0,0,0,0,0,0,0,0,25,0,0,0},
					{0,0,0,0,0,5,9,0,0,0,27,0,0,0,28,0,24,0,0,23,0,0,9,2,2,2,2,2,1,2,2,2,2,4,5,9,0,16,16,16,24,0,0,23,0,0,0,29,0,0,0,9,5,0,0},
					{0,0,0,0,0,5,9,9,9,9,9,9,16,16,16,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,16,16,16,9,9,9,9,9,9,9,9,9,9,9,9,5,2,0},
					{0,0,0,0,0,5,5,5,5,5,9,0,16,16,16,0,0,0,11,11,11,11,25,11,11,0,0,0,0,0,0,11,11,11,11,11,0,16,16,16,0,0,0,0,0,0,0,9,5,5,5,5,5,2,2},
					{0,0,0,0,0,0,25,0,0,0,19,0,16,16,16,0,0,0,0,0,11,11,25,11,0,0,0,0,0,0,0,0,0,11,11,11,0,16,16,16,0,0,0,0,0,0,0,19,0,0,0,25,2,2,0},
					{0,0,0,0,0,0,25,0,0,0,7,0,16,16,16,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,0,0,0,0,30,30,0,16,16,16,0,31,0,30,30,30,0,7,0,0,0,25,0,0,0},
					{0,0,0,0,0,0,25,0,0,0,32,0,16,16,16,0,0,0,33,0,0,0,25,0,33,0,0,0,0,33,34,0,0,0,16,16,0,16,16,16,0,16,16,16,16,16,0,0,0,0,0,25,0,0,0},
					{0,0,0,0,0,0,25,0,0,0,0,0,16,16,16,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,16,16,0,0,0,0,0,0,0,0,0,0,0,25,0,0,0},
					{0,40,41,0,0,0,25,0,0,0,0,0,16,16,16,0,35,0,36,0,35,0,25,0,36,0,35,0,35,0,37,0,0,38,0,38,0,16,16,16,0,39,38,0,38,0,0,22,0,0,0,25,0,0,0},
					{43,43,43,40,41,0,25,0,0,44,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,44,0,0,25,0,0,42},
					{43,45,45,43,43,7,7,7,7,46,46,46,7,7,7,7,7,7,46,46,46,46,46,46,7,7,46,46,46,46,46,46,46,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,43,43},
					{45,45,45,45,46,7,7,7,7,7,7,46,46,46,46,46,7,7,7,7,46,46,46,46,46,46,7,7,7,7,7,7,7,46,46,46,46,46,46,7,7,7,7,7,7,7,7,7,7,7,7,7,7,45,45}
				};
				//i = vertical, j = horizontal
				UseStarterHouseHalfCircle(spawnX, spawnY, 0, _structure.GetLength(1) / 2, _structure.GetLength(0));
				for (int confirmPlatforms = 0; confirmPlatforms < 3; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 1:
										tile.active(true);
										tile.type = 192;
										tile.slope(0);
										tile.halfBrick(true);
										break;
									case 2:
										tile.active(true);
										tile.type = 192;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = 192;
										tile.slope(2);
										tile.halfBrick(false);
										break;
									case 4:
										tile.active(true);
										tile.type = 192;
										tile.slope(1);
										tile.halfBrick(false);
										break;
									case 5:
										tile.active(true);
										tile.type = 191;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 6:
										tile.active(true);
										tile.type = 191;
										tile.slope(3);
										tile.halfBrick(false);
										break;
									case 7:
										tile.active(true);
										tile.type = 38;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 8:
										tile.active(true);
										tile.type = 191;
										tile.slope(2);
										tile.halfBrick(false);
										break;
									case 9:
										tile.active(true);
										tile.type = 30;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 10:
										tile.active(true);
										tile.type = 191;
										tile.slope(4);
										tile.halfBrick(false);
										break;
									case 11:
										tile.active(true);
										tile.type = 51;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 12:
										tile.active(true);
										tile.type = 192;
										tile.slope(4);
										tile.halfBrick(false);
										break;
									case 13:
										tile.active(true);
										tile.type = 192;
										tile.slope(3);
										tile.halfBrick(false);
										break;
									case 14:
										tile.active(true);
										tile.type = 191;
										tile.slope(1);
										tile.halfBrick(false);
										break;
									case 15:
										if (confirmPlatforms == 0)
											tile.active(false);
										else if (confirmPlatforms == 1)
										{
											WorldGen.PlaceTile(k, l, TileID.Books, true, true, -1, Main.rand.Next(5));
											tile.slope(0);
											tile.halfBrick(false);
										}
										break;
									case 16:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 19, true, true, -1, 0);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 17:
										tile.active(true);
										tile.type = 30;
										tile.slope(3);
										tile.halfBrick(false);
										break;
									case 18:
										tile.active(true);
										tile.type = 30;
										tile.slope(4);
										tile.halfBrick(false);
										break;
									case 19:
										tile.active(true);
										tile.type = 54;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 20:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 240, true, true, -1, 48);
										}
										break;
									case 21:
										tile.active(true);
										tile.type = 191;
										tile.slope(0);
										tile.halfBrick(true);
										break;
									case 32:
									case 22:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 10, true, true, -1, 0);
										}
										break;
									case 23:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											int temp = Main.player[Main.myPlayer].direction;
											Main.player[Main.myPlayer].direction = -1;
											WorldGen.PlaceTile(k, l, 79, true, true, Main.myPlayer, 0);
											Main.player[Main.myPlayer].direction = temp;
										}
										break;
									case 24:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 18, true, true, -1, 0);
										}
										break;
									case 25:
										tile.active(true);
										tile.type = 124;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 26:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, ModContent.TileType<RuinedChestTile>(), true, true, -1, 0);
										}
										break;
									case 27:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 10, true, true, -1, 0);
										}
										break;
									case 28:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 304, true, true, -1, 0);
										}
										break;
									case 29:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 10, true, true, -1, 0);
										}
										break;
									case 30:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 13, true, true, -1, 0);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 31:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 103, true, true, -1, 2);
										}
										break;
									case 33:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 13, true, true, -1, 4);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 34:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 49, true, true, -1, 0);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 35:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 15, true, true, -1, 21);
										}
										break;
									case 36:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 14, true, true, -1, 16);
										}
										break;
									case 37:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 14, true, true, -1, 17);
										}
										break;
									case 38:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 21, true, true, -1, 5);
										}
										break;
									case 39:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 94, true, true, -1, 0);
										}
										break;
									case 40:
										tile.active(true);
										tile.type = 2;
										tile.slope(0);
										tile.halfBrick(true);
										break;
									case 41:
										tile.active(true);
										tile.type = 73;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 42:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 254, true, true, -1, 4);
										}
										break;
									case 43:
										tile.active(true);
										tile.type = 2;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 44:
										tile.active(true);
										tile.type = 38;
										tile.slope(0);
										tile.halfBrick(true);
										break;
									case 45:
										tile.active(true);
										tile.type = 0;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 46:
										tile.active(true);
										tile.type = 1;
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				UseStarterHouseHalfCircle(spawnX, spawnY, 1, _structure.GetLength(1) / 2, 9);
			}
			if (type == 4)
			{
				int[,] _structure = {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
					{0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,2,2,0,0,3,0,0,0,0,0,0,0,0},
					{0,0,0,0,2,2,2,2,2,3,2,2,2,2,2,2,0,0},
					{0,0,0,2,2,2,2,2,2,3,2,2,2,2,2,2,0,0},
					{4,4,4,2,2,2,2,2,5,3,5,2,2,2,2,2,0,0},
					{4,4,4,2,2,2,2,5,5,3,5,5,2,2,2,2,4,4},
					{4,4,4,4,4,4,4,5,5,3,5,5,4,4,4,6,6,6},
					{4,4,4,4,4,4,4,4,4,4,4,4,4,4,6,6,6,6},
					{4,4,4,4,4,4,4,4,4,4,4,4,4,6,6,6,6,6}
				};
				int PosX = spawnX - _structure.GetLength(1) / 2;
				int PosY = spawnY - _structure.GetLength(0) + 10;
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.wall = 0;
									break;
								case 1:
									tile.wall = 106;
									break;
								case 2:
									tile.wall = 4;
									break;
								case 3:
									tile.wall = 78;
									break;
								case 4:
									tile.wall = 2;
									break;
								case 5:
									tile.wall = 1;
									break;
								case 6:
									tile.wall = 59;
									break;
							}
						}
					}
				}
				_structure = new int[,] {
					{0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,1,1},
					{2,0,0,0,2,1,1,2,0,0,0,2,1,1,1,1,1,1,1},
					{1,1,3,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1},
					{1,1,3,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1},
					{1,1,3,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1},
					{1,1,3,1,1,1,1,1,1,3,4,4,1,1,1,1,1,1,1},
					{1,1,3,7,1,1,1,1,4,3,4,4,5,1,6,1,1,1,1},
					{1,8,8,8,8,9,9,8,8,8,8,8,8,8,8,8,8,8,1},
					{0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
					{-1,8,0,0,-2,-2,1,1,1,1,-2,-2,-2,-2,-2,0,0,8,-1},
					{-1,8,0,-2,-2,1,1,1,1,1,1,1,1,1,-2,-2,0,8,-1},
					{-1,8,0,1,1,11,11,1,1,1,1,1,1,1,1,1,0,8,-1},
					{-1,8,0,10,1,11,11,11,1,1,1,1,5,1,5,1,0,8,-1},
					{13,8,8,8,8,8,14,14,1,12,1,14,14,8,8,14,14,14,14},
					{15,15,14,14,14,14,8,8,8,8,14,14,14,8,8,8,14,14,13},
					{15,15,15,15,14,14,14,14,14,14,14,14,8,8,8,15,15,15,15}
				};
				//i = vertical, j = horizontal
				UseStarterHouseHalfCircle(spawnX, spawnY, 0, _structure.GetLength(1) / 2, _structure.GetLength(0));
				for (int confirmPlatforms = 0; confirmPlatforms < 3; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case -2:
										tile.active(true);
										tile.type = TileID.Cobweb;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 0:
										tile.active(true);
										tile.type = 30;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 1:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 2:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, TileID.Banners, true, true, -1, 0);
										}
										break;
									case 3:
										tile.active(true);
										tile.type = 124;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 4:
										if (confirmPlatforms == 0)
											tile.active(false);
										else if (!tile.active())
										{
											WorldGen.PlaceTile(k, l, TileID.MetalBars, true, true, -1, WorldGen.IronTierOre == 6 ? 2 : 3);
											tile.slope(0);
											tile.halfBrick(false);
										}
										break;
									case 5:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, TileID.FishingCrate, true, true, -1, 0);
										}
										break;
									case 6:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, ModContent.TileType<RuinedChestTile>(), true, true, -1, 0);
										}
										break;
									case 7:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, TileID.Anvils, true, true, -1, WorldGen.IronTierOre == 6 ? 0 : 1);
										}
										break;
									case 8:
										tile.active(true);
										tile.type = 38;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 9:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0);
										}
										break;
									case 10:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 21, true, true, -1, 5);
										}
										break;
									case 11:
										tile.active(true);
										tile.type = 332;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 12:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 215, true, true, -1, 0);
										}
										break;
									case 13:
										tile.active(true);
										tile.type = 2;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 14:
										tile.active(true);
										tile.type = 1;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 15:
										tile.active(true);
										tile.type = 0;
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				//UseStarterHouseHalfCircle(spawnX, spawnY, 1, _structure.GetLength(1) / 2, 15);
			}
			if (type == 5)
			{
				int[,] _structure = {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,2,2,3,2,2,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,0,0,3,0,0,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,2,2,3,2,2,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,2,2,3,2,2,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,2,2,3,2,2,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,2,2,3,2,2,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,2,2,3,2,2,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,2,2,3,2,2,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,2,2,3,2,2,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,2,2,3,2,2,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,2,2,3,2,2,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,2,2,0,2,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4},
					{0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4},
					{0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4},
					{0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4}
				};
				int PosX = spawnX - _structure.GetLength(1) / 2;
				int PosY = spawnY - _structure.GetLength(0) + 6;
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.wall = 0;
									break;
								case 1:
									tile.wall = 5;
									break;
								case 2:
									tile.wall = 4;
									break;
								case 3:
									tile.wall = 78;
									break;
							}
						}
					}
				}
				_structure = new int[,] {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,2,2,2,0,0,0,2,2,2,1,0,0,2,2,2,0,0},
					{0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0},
					{0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0},
					{0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0},
					{0,0,0,0,0,2,4,4,4,4,4,4,4,2,0,0,0,0,0},
					{0,0,0,0,0,2,4,5,5,5,5,5,4,2,0,0,0,0,0},
					{0,0,0,0,0,3,4,3,3,3,3,3,4,3,0,0,0,0,0},
					{0,0,0,0,0,2,4,0,0,0,0,0,4,2,0,0,0,0,0},
					{0,0,0,0,0,2,4,6,0,0,0,0,4,2,0,0,0,0,0},
					{0,0,0,0,0,3,0,0,0,0,0,0,0,3,0,0,0,0,0},
					{0,0,0,0,0,2,6,0,6,0,0,7,7,2,0,0,0,0,0},
					{0,0,0,0,0,2,8,8,8,8,8,8,8,2,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0},
					{0,0,0,0,2,2,2,0,0,11,0,0,2,2,2,0,0,0,0},
					{0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0},
					{0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0},
					{0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
					{12,12,13,2,2,2,2,2,2,2,2,2,2,2,2,2,2,12,12},
					{13,12,13,13,2,2,2,14,14,14,14,14,14,2,2,13,13,13,13},
					{13,13,13,13,13,14,14,14,2,2,2,14,14,14,13,13,13,13,13},
					{13,13,13,13,13,13,14,2,2,2,13,13,13,13,13,13,13,13,13},
					{13,13,15,15,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13}
				};
				//i = vertical, j = horizontal
				UseStarterHouseHalfCircle(spawnX, spawnY, 0, _structure.GetLength(1) / 2, _structure.GetLength(0));
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 1:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, ModContent.TileType<RuinedChestTile>(), true, true, -1, 0);
										}
										break;
									case 2:
										tile.active(true);
										tile.type = 38;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = 30;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 4:
										tile.active(true);
										tile.type = 273;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 5:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 19, true, true, -1, 0);
										tile.slope(0);
										tile.halfBrick(true);
										break;
									case 6:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 376, true, true, -1, 0);
										}
										break;
									case 7:
										if (confirmPlatforms == 1)
										{
											tile.active(true);
											tile.type = 332;
											tile.slope(0);
											tile.halfBrick(false);
										}
										break;
									case 8:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 19, true, true, -1, 0);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 9:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 10, true, true, -1, 15);
										}
										break;
									case 10:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 10, true, true, -1, 15);
										}
										break;
									case 11:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 215, true, true, -1, 0);
										}
										break;
									case 12:
										tile.active(true);
										tile.type = 2;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 15:
										tile.active(true);
										tile.type = 0;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 14:
										tile.active(true);
										tile.type = 1;
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				UseStarterHouseHalfCircle(spawnX, spawnY, 1, _structure.GetLength(1) / 2, 8);
			}
			if (type == 6)
			{
				int[,] _structure = {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,1,2,0,0,1,0,0,2,1,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0},
					{0,0,0,0,0,3,0,0,2,0,2,2,0,1,2,2,1,1,0,0,2,0,0,0,1,0,1,0,1,0,2,0,0,0,0,0,0},
					{0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0},
					{4,4,0,0,0,0,0,0,0,0,5,5,5,5,5,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5},
					{4,4,0,4,4,4,0,0,0,5,5,5,5,5,5,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5},
					{4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5},
					{4,4,4,6,5,5,5,5,7,7,7,5,5,5,5,3,8,5,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5},
					{4,4,4,4,4,5,5,5,7,7,7,7,7,7,7,8,8,7,7,7,7,7,8,8,8,8,8,5,5,5,5,5,5,5,5,5,5},
					{4,6,4,4,4,4,5,5,7,7,7,7,7,7,7,8,7,7,7,7,7,7,7,5,5,8,8,7,7,5,5,5,5,5,5,5,5},
					{4,4,4,4,4,6,5,5,0,7,7,7,7,7,7,7,7,8,8,5,5,7,5,5,5,8,5,5,7,7,5,5,5,5,5,5,5},
					{4,4,4,6,4,4,5,5,5,7,7,7,7,7,7,7,7,8,5,5,5,5,5,5,5,5,5,5,7,7,5,5,5,5,5,5,5},
					{4,4,6,6,6,6,4,5,5,5,5,0,0,7,7,7,7,8,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5},
					{5,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,0,7,7,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5},
					{5,5,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,9,5},
					{5,9,4,4,6,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5},
					{9,9,9,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5},
					{9,5,5,5,4,4,4,4,5,5,5,5,5,5,5,5,9,9,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5}
				};
				int PosX = spawnX - _structure.GetLength(1) / 2;
				int PosY = spawnY - _structure.GetLength(0) + 16;
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.wall = 0;
									break;
								case 1:
									tile.wall = 5;
									break;
								case 2:
									tile.wall = 16;
									break;
								case 3:
									tile.wall = 1;
									break;
								case 4:
									tile.wall = 63;
									break;
								case 5:
									if (tile.wall == 0)
										tile.wall = WallID.DirtUnsafe;
									break;
								case 6:
									tile.wall = 65;
									break;
								case 7:
									tile.wall = 66;
									break;
								case 8:
									tile.wall = 68;
									break;
								case 9:
									tile.wall = 59;
									break;
							}
						}
					}
				}
				_structure = new int[,] {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,0,2,6,0,0,0,0,0},
					{0,0,0,0,0,0,5,2,2,5,0,0,0,0,0,0,0,0,0,0,0,0,4,0,5,5,0,0,9,9,2,2,0,0,0,0,0},
					{0,0,10,1,2,5,10,2,2,11,7,0,5,0,0,0,0,0,0,12,12,13,14,14,15,9,8,0,9,10,2,2,16,0,0,17,0},
					{1,1,2,2,2,13,14,14,14,14,14,14,14,15,5,5,5,6,13,14,14,14,14,14,14,14,14,14,14,14,2,2,14,14,18,19,17},
					{14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,10,10,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,20},
					{21,21,10,10,10,10,10,14,14,10,10,10,14,14,14,5,10,14,10,10,14,14,14,14,14,14,10,14,14,10,10,10,10,10,10,10,21},
					{21,21,21,21,10,10,10,10,10,14,14,14,14,10,10,10,5,14,10,10,14,14,10,10,10,14,14,10,10,10,10,10,10,21,21,21,21},
					{21,21,21,21,21,21,21,20,20,20,20,21,21,21,20,5,5,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21},
					{21,21,21,21,21,21,21,20,22,0,23,20,20,20,20,5,10,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21},
					{21,21,21,21,21,21,21,20,22,0,0,22,22,23,20,0,0,20,20,0,0,0,0,0,0,0,23,20,20,21,21,21,21,21,21,21,21},
					{21,21,21,21,21,21,21,20,24,5,0,22,22,0,22,0,0,22,0,0,0,0,0,0,0,0,0,5,23,20,21,21,21,21,21,21,21},
					{21,21,21,21,21,21,21,21,20,25,5,0,0,0,22,0,0,0,0,0,0,0,0,0,0,0,0,5,5,23,20,21,21,21,21,21,21},
					{20,20,21,21,21,21,21,21,21,20,25,26,0,5,22,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,20,21,21,21,21,21,21},
					{21,21,21,21,21,21,21,21,21,21,20,20,20,24,22,10,10,0,0,0,0,0,0,0,0,0,0,0,0,5,20,21,21,21,21,21,21},
					{21,21,20,21,21,21,21,21,21,21,21,21,21,20,20,20,10,10,27,27,27,27,27,27,27,0,0,27,27,27,20,21,21,21,21,21,21},
					{21,21,21,21,21,21,21,21,21,21,21,21,21,20,21,20,21,20,20,20,24,24,29,29,29,28,0,29,29,30,20,21,21,21,21,21,21},
					{21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21},
					{21,21,21,21,20,21,21,21,21,21,21,21,21,21,21,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21},
					{21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21}
				};
				UseStarterHouseHalfCircle(spawnX, spawnY - 1, 0, _structure.GetLength(1) / 2, _structure.GetLength(0));
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 1:
										tile.active(true);
										tile.type = 57;
										tile.slope(0);
										tile.halfBrick(true);
										break;
									case 2:
										tile.active(true);
										tile.type = 57;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = 57;
										tile.slope(2);
										tile.halfBrick(false);
										break;
									case 4:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 85, true, true, -1, 2);
										}
										break;
									case 5:
										tile.active(true);
										tile.type = 51;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 6:
										tile.active(true);
										tile.type = 1;
										tile.slope(0);
										tile.halfBrick(true);
										break;
									case 7:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 85, true, true, -1, 4);
										}
										break;
									case 8:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 85, true, true, -1, 1);
										}
										break;
									case 9:
										tile.active(true);
										tile.type = 331;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 10:
										tile.active(true);
										tile.type = 1;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 11:
										tile.active(true);
										tile.type = 57;
										tile.slope(1);
										tile.halfBrick(false);
										break;
									case 12:
										tile.active(true);
										tile.type = 332;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 13:
										tile.active(true);
										tile.type = 38;
										tile.slope(2);
										tile.halfBrick(false);
										break;
									case 14:
										tile.active(true);
										tile.type = 38;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 15:
										tile.active(true);
										tile.type = 38;
										tile.slope(1);
										tile.halfBrick(false);
										break;
									case 16:
										tile.active(true);
										tile.type = 1;
										tile.slope(1);
										tile.halfBrick(false);
										break;
									case 17:
										tile.active(true);
										tile.type = 3;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 18:
										tile.active(true);
										tile.type = 38;
										tile.slope(0);
										tile.halfBrick(true);
										break;
									case 19:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 78, true, true, -1, 0);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 20:
										tile.active(true);
										tile.type = 2;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 21:
										tile.active(true);
										tile.type = 0;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 22:
										tile.active(true);
										tile.type = 52;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 23:
										tile.active(true);
										tile.type = 2;
										tile.slope(4);
										tile.halfBrick(false);
										break;
									case 24:
										tile.active(true);
										tile.type = 2;
										tile.slope(0);
										tile.halfBrick(true);
										break;
									case 25:
										tile.active(true);
										tile.type = 2;
										tile.slope(1);
										tile.halfBrick(false);
										break;
									case 26:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, ModContent.TileType<RuinedChestTile>(), true, true, -1, 0);
										}
										break;
									case 27:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
											tile.liquid = 46;
											tile.liquidType(0);
										}
										break;
									case 28:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, ModContent.TileType<EnchantedSwordShrineTile>(), true, true, -1, 0);
										}
										break;
									case 29:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
											tile.liquid = 255;
											tile.liquidType(0);
										}
										break;
									case 30:
										tile.active(true);
										tile.type = 2;
										tile.slope(2);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
			}
			if (type == 7)
			{
				int[,] _structure = {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2}
				};
				int PosX = spawnX - _structure.GetLength(1) / 2;
				int PosY = spawnY - _structure.GetLength(0) + 15;
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.wall = 0;
									break;
								case 1:
									tile.wall = 60;
									break;
								case 2:
									if (tile.wall == 0)
										tile.wall = 2;
									break;
							}
						}
					}
				}
				_structure = new int[,] {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,2,2,1,1,1,1,1,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,1,1,1,2,2,2,1,1,2,2,1,1,2,2,2,2,1,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,1,1,2,2,1,1,1,1,1,2,2,2,2,1,1,2,2,2,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,2,2,1,1,1,1,1,3,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,3,1,1,1,1,1,1,2,2,1,1,0,3,0,0,3,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,3,0,4,1,1,1,4,2,2,4,4,0,3,0,0,3,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,3,0,0,4,3,4,2,2,2,4,0,0,3,0,0,3,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,3,0,0,0,3,4,2,2,4,4,0,0,3,5,0,3,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,2,2,2,2,0,0,6,6,6,6,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,8,8,9,0,0,0,0,2,2,2,0,0,0,0,0,0,10,2,2,0,0,0,0,0,0},
					{11,12,12,12,12,12,8,8,13,8,8,12,12,12,2,2,2,2,14,14,12,12,2,2,12,2,2,12,12,12,12,8},
					{8,14,14,14,14,14,14,14,14,12,12,12,14,14,2,2,2,2,2,14,12,2,2,14,14,12,12,2,14,14,13,13},
					{13,13,12,12,14,14,14,12,12,12,12,12,12,12,2,2,2,2,2,2,2,2,12,12,12,12,12,13,13,13,13,13},
					{8,13,13,13,13,13,13,13,13,13,13,13,12,14,2,2,2,2,13,13,13,13,13,13,13,13,13,13,13,13,13,13},
					{13,13,13,13,13,13,13,13,13,13,13,13,13,2,2,2,2,2,14,14,14,13,13,13,13,13,13,13,13,13,13,13},
					{13,13,13,13,13,13,8,8,8,2,2,13,2,2,2,2,2,2,2,2,14,14,13,13,13,13,13,13,13,13,13,13},
					{13,13,13,13,13,13,8,4,8,8,13,2,2,2,13,2,2,2,13,2,2,14,13,13,13,13,13,13,13,13,13,13},
					{13,13,13,13,13,8,8,4,4,2,2,2,4,4,13,2,2,13,2,13,2,2,8,13,13,13,13,13,13,13,13,13},
					{13,13,13,13,8,15,0,0,0,8,8,0,0,0,2,4,2,13,2,13,0,0,8,13,13,13,13,13,13,13,13,13},
					{13,13,13,13,8,4,0,0,0,0,0,0,0,0,2,4,2,4,4,2,0,0,2,8,13,13,13,13,13,13,13,13},
					{13,13,13,13,8,16,0,0,0,0,0,0,0,0,0,4,2,4,0,0,0,0,0,8,13,13,13,13,13,13,13,13},
					{13,13,13,13,13,8,0,0,0,0,0,0,0,0,0,0,4,4,0,0,17,0,18,8,13,13,13,13,13,13,13,13},
					{13,13,13,13,13,8,16,0,0,0,0,0,0,0,0,0,0,0,19,0,8,8,8,13,13,13,13,13,13,13,13,13},
					{13,13,13,13,13,13,8,20,0,0,0,0,0,0,21,4,4,4,8,8,8,13,13,13,13,13,13,13,13,13,13,13},
					{13,13,13,13,13,13,8,8,8,21,0,0,20,0,8,8,4,18,8,13,13,13,13,13,13,13,13,13,13,13,13,13},
					{13,13,13,13,13,13,13,13,8,8,8,8,8,8,8,8,8,8,13,13,14,13,13,13,8,13,13,13,13,13,13,13}
				};
				//i = vertical, j = horizontal
				UseStarterHouseHalfCircle(spawnX, spawnY - 3, 0, _structure.GetLength(1) / 2, _structure.GetLength(0));
				for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 1:
										tile.active(true);
										tile.type = 192;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = 191;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = 353;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 4:
										tile.active(true);
										tile.type = 51;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 5:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, ModContent.TileType<RuinedChestTile>(), true, true, -1, 0);
										}
										break;
									case 6:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 19, true, true, -1, 23);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 7:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 85, true, true, -1, 1);
										}
										break;
									case 8:
										tile.active(true);
										tile.type = 2;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 9:
										tile.active(true);
										tile.type = 2;
										tile.slope(0);
										tile.halfBrick(true);
										break;
									case 10:
										tile.active(true);
										tile.type = 191;
										tile.slope(0);
										tile.halfBrick(true);
										break;
									case 11:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 227, true, true, -1, 3);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 12:
										tile.active(true);
										tile.type = 38;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 13:
										tile.active(true);
										tile.type = 0;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 14:
										tile.active(true);
										tile.type = 1;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 15:
										tile.active(true);
										tile.type = 2;
										tile.slope(3);
										tile.halfBrick(false);
										break;
									case 16:
										tile.active(true);
										tile.type = 2;
										tile.slope(1);
										tile.halfBrick(false);
										break;
									case 17:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 227, true, true, -1, 8);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 18:
										tile.active(true);
										tile.type = 2;
										tile.slope(2);
										tile.halfBrick(false);
										break;
									case 19:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 227, true, true, -1, 11);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 20:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 227, true, true, -1, 10);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 21:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 227, true, true, -1, 9);
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
			}
			if (type == 8)
			{
				int[,] _structure = {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,2,1,2,3,3,3,2,1,1,2,3,3,3,2,1,2,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,2,2,1,2,3,3,3,2,1,1,2,3,3,3,2,1,2,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,2,2,1,2,3,3,3,2,1,1,2,3,3,3,2,1,2,2,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,2,2,2,1,2,3,3,3,2,1,1,2,3,3,3,2,1,2,2,2,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,2,2,2,2,1,2,3,3,3,2,1,1,2,3,3,3,2,1,2,2,2,2,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,2,2,2,2,1,2,3,3,3,2,1,1,2,3,3,3,2,1,2,2,2,2,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,2,2,2,2,1,2,3,3,3,2,1,1,2,3,3,3,2,1,2,2,2,2,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,2,2,2,2,1,2,3,3,3,2,1,1,2,3,3,3,2,1,2,2,2,2,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,2,1,0,3,3,3,2,1,1,2,3,3,3,0,1,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,4,4,4,4,1,4,5,3,3,4,1,1,4,3,3,3,4,1,4,4,4,4,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,4,4,4,4,1,4,5,5,3,4,1,1,4,3,3,3,4,1,4,4,4,4,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,4,4,4,4,1,4,5,5,5,4,1,1,4,3,3,3,4,1,4,4,4,4,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,4,4,4,4,1,4,5,5,5,5,1,1,4,3,3,3,4,1,4,4,4,4,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,6,6,6,6,1,5,5,5,5,5,5,1,6,3,3,3,6,1,6,6,6,6,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,6,6,6,6,5,5,5,5,5,5,5,5,6,3,3,3,6,1,6,6,6,6,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,1,5,5,5,5,5,5,5,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
				};
				int PosX = spawnX - _structure.GetLength(1) / 2;
				int PosY = spawnY - _structure.GetLength(0) + 4;
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.wall = 0;
									break;
								case 1:
									tile.wall = 78;
									break;
								case 2:
									tile.wall = 4;
									break;
								case 3:
									tile.wall = 21;
									break;
								case 4:
									tile.wall = 27;
									break;
								case 5:
									tile.wall = 5;
									break;
								case 6:
									tile.wall = 1;
									break;
							}
						}
					}
				}
				_structure = new int[,]  {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,2,2,2,2,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,1,1,2,2,2,3,3,3,2,2,2,2,3,3,3,2,2,2,1,1,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,1,1,2,2,4,0,0,0,0,4,4,4,0,0,0,0,0,4,2,2,1,1,0,0,0,0,0,0,0},
					{0,0,0,0,0,1,1,2,2,4,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,2,2,1,1,0,0,0,0,0,0},
					{0,0,0,0,1,1,2,2,4,4,5,0,0,0,0,0,5,5,0,0,0,0,0,5,4,4,2,2,1,1,0,0,0,0,0},
					{0,0,0,0,2,2,2,4,6,7,0,0,0,0,0,0,0,0,0,0,0,9,7,0,0,10,4,2,2,2,0,0,0,0,0},
					{0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,4,1,1,0,0,0,0,0},
					{0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0},
					{0,0,0,0,12,3,0,0,0,0,0,0,0,0,0,0,15,10,0,0,0,0,0,0,0,0,0,0,3,12,0,0,0,0,0},
					{0,0,0,0,16,3,0,0,11,0,13,0,0,0,14,0,17,0,0,0,0,11,0,0,0,11,0,0,3,16,0,0,0,0,0},
					{0,0,0,0,1,1,2,2,2,2,2,2,18,5,5,5,5,5,5,5,5,5,2,2,2,2,2,2,1,1,0,0,0,0,0},
					{0,0,0,0,2,2,2,4,4,0,0,4,0,18,0,0,0,0,0,0,0,0,19,0,4,4,4,2,2,2,0,0,0,0,0},
					{0,0,0,0,2,2,4,4,0,0,7,15,20,0,18,0,0,0,0,0,0,0,0,0,0,20,15,4,2,2,0,0,2,2,2},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19,23,19},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,18,0,0,0,0,0,20,6,0,0,0,0,0,0,0,0,0,23,0},
					{0,0,0,0,0,21,0,0,0,0,0,0,0,0,0,4,4,18,0,0,0,0,0,0,0,0,0,0,22,0,0,0,0,23,0},
					{0,0,0,0,2,2,27,0,24,0,11,0,0,11,0,17,0,0,18,0,25,0,26,0,0,11,0,27,2,2,0,0,0,23,0},
					{0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,23,0},
					{28,28,28,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
					{29,28,28,28,28,28,1,28,28,1,1,1,28,1,1,1,1,28,1,28,28,1,1,1,1,28,1,28,28,28,28,28,28,29,29},
					{29,29,29,29,29,29,29,29,1,1,1,28,28,28,1,1,28,28,28,28,28,28,1,1,28,1,1,1,1,29,29,29,29,29,29}
				};
				//i = vertical, j = horizontal
				UseStarterHouseHalfCircle(spawnX, spawnY, 0, _structure.GetLength(1) / 2, _structure.GetLength(0));
				for (int confirmPlatforms = 0; confirmPlatforms < 3; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 1:
										tile.active(true);
										tile.type = 38;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = 30;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = 54;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 4:
										tile.active(true);
										tile.type = 51;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 5:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 19, true, true, -1, 0);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 6:
									case 7:
									case 9:
									case 15:
									case 20:
										if (confirmPlatforms == 2)
											tile.active(false);
										WorldGen.PlaceTile(k, l, TileID.Books, true, true, -1, Main.rand.Next(6));
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 8:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 245, true, true, -1, 3);
										}
										break;
									case 10:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 13, true, true, -1, 0);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 11:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 101, true, true, -1, 0);
										}
										break;
									case 12:
										tile.active(true);
										tile.type = 3;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 13:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, ModContent.TileType<RuinedChestTile>(), true, true, -1, 0);
										}
										break;
									case 14:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 89, true, true, -1, 1);
										}
										break;
									case 16:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 78, true, true, -1, 0);
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 17:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 18, true, true, -1, 0);
										}
										break;
									case 18:
										if (confirmPlatforms == 0)
											tile.active(false);
										WorldGen.PlaceTile(k, l, 19, true, true, -1, 0);
										tile.slope(1);
										tile.halfBrick(false);
										break;
									case 19:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 91, true, true, -1, 0);
										}
										break;
									case 21:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 10, true, true, -1, 13);
										}
										break;
									case 22:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 10, true, true, -1, 13);
										}
										break;
									case 23:
										tile.active(true);
										tile.type = TileID.WoodenBeam;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 24:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 105, true, true, -1, 20);
										}
										break;
									case 25:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 15, true, true, -1, 0);
										}
										break;
									case 26:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 14, true, true, -1, 16);
										}
										break;
									case 27:
										tile.active(true);
										tile.type = 30;
										tile.slope(0);
										tile.halfBrick(true);
										break;
									case 28:
										tile.active(true);
										tile.type = 1;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 29:
										tile.active(true);
										tile.type = 0;
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				UseStarterHouseHalfCircle(spawnX, spawnY + 1, 1, _structure.GetLength(1) / 2, 8);

			}
			if (type == 9)
			{
				int[,] _structure = {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,3,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,3,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,2,2,3,3,0,0,0,0,0,0},
					{0,0,0,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,2,2,3,3,3,0,0,0,0,0},
					{0,0,0,3,0,0,0,0,0,0,3,0,0,0,0,0,0,4,3,3,3,2,2,3,3,3,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,3,3,3,2,2,3,3,3,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,2,3,3,2,2,3,2,2,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,3,2,1,0,0,0,0,0},
					{0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,1,1,2,2,2,1,1,1,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,1,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
				};
				int PosX = spawnX - _structure.GetLength(1) / 2;
				int PosY = spawnY - _structure.GetLength(0) + 2;
				//i = vertical, j = horizontal
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.wall = 0;
									break;
								case 1:
									tile.wall = 5;
									break;
								case 2:
									tile.wall = 1;
									break;
								case 3:
									tile.wall = 4;
									break;
								case 4:
									tile.wall = 78;
									break;
								case 5:
									tile.wall = 106;
									break;
							}
						}
					}
				}
				_structure = new int[,] {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,2,0,1,1,1,1,1,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,3,3,2,2,0,0,3,3,1,1,1,0,0},
					{0,0,3,3,3,3,3,3,3,3,3,3,0,0,1,1,1,3,3,3,2,0,0,0,3,3,3,1,1,1,0},
					{0,3,3,3,3,3,3,3,3,3,3,3,3,0,1,1,3,3,3,2,2,0,0,0,2,3,3,3,1,1,0},
					{0,3,3,3,4,2,2,2,0,4,3,3,3,0,0,0,3,3,2,0,0,0,0,0,2,2,3,3,0,0,0},
					{0,0,5,4,0,0,0,0,0,0,4,5,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,3,0,0,0},
					{0,0,5,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,3,0,0,0},
					{0,0,5,0,0,0,0,0,0,0,0,5,0,0,0,0,6,0,0,0,8,8,7,0,8,8,1,1,0,0,0},
					{0,0,5,0,8,8,0,0,0,0,0,5,0,0,0,0,1,1,0,0,0,0,0,0,0,8,1,1,0,0,0},
					{0,0,5,8,8,8,11,0,0,9,0,5,10,0,0,1,1,1,1,7,0,7,0,7,0,1,1,1,1,0,0},
					{12,12,12,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
					{1,12,12,1,1,1,12,1,12,12,1,12,1,1,12,1,1,12,12,12,1,12,1,12,1,12,12,1,12,13,13},
					{13,13,13,13,13,13,13,13,13,13,13,13,13,12,12,12,1,12,12,12,12,1,1,12,12,1,1,12,13,13,13}
				};
				//i = vertical, j = horizontal
				UseStarterHouseHalfCircle(spawnX, spawnY, 0, _structure.GetLength(1) / 2, _structure.GetLength(0));
				for (int confirmPlatforms = 0; confirmPlatforms < 3; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
				{
					for (int i = 0; i < _structure.GetLength(0); i++)
					{
						for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
						{
							int k = PosX + j;
							int l = PosY + i;
							if (WorldGen.InWorld(k, l, 30))
							{
								Tile tile = Framing.GetTileSafely(k, l);
								switch (_structure[i, j])
								{
									case 0:
										if (confirmPlatforms == 0)
										{
											tile.active(false);
											tile.halfBrick(false);
											tile.slope(0);
										}
										break;
									case 1:
										tile.active(true);
										tile.type = 38;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 2:
										tile.active(true);
										tile.type = 51;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 3:
										tile.active(true);
										tile.type = 30;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 4:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 91, true, true, -1, 0);
										}
										break;
									case 5:
										tile.active(true);
										tile.type = 124;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 6:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 10, true, true, -1, 0);
										}
										break;
									case 7:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 376, true, true, -1, 0);
										}
										break;
									case 8:
										tile.active(true);
										tile.type = 332;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 9:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 17, true, true, -1, 0);
										}
										break;
									case 10:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, ModContent.TileType<RuinedChestTile>(), true, true, -1, 0);
										}
										break;
									case 11:
										if (confirmPlatforms == 1)
										{
											tile.active(false);
											tile.slope(0);
											tile.halfBrick(false);
											WorldGen.PlaceTile(k, l, 16, true, true, -1, 0);
										}
										break;
									case 12:
										tile.active(true);
										tile.type = 1;
										tile.slope(0);
										tile.halfBrick(false);
										break;
									case 13:
										tile.active(true);
										tile.type = 0;
										tile.slope(0);
										tile.halfBrick(false);
										break;
								}
							}
						}
					}
				}
				UseStarterHouseHalfCircle(spawnX, spawnY - 1, 1, _structure.GetLength(1) / 2, 10);
			}
			if (type == 10)
			{
				GenerateAstrobitStarterHouse(spawnX, spawnY, waterbolt);
			}
			if (type == 11)
			{
				GenerateMushnibStarterHouse(spawnX, spawnY, waterbolt);
			}
		}
		public static void GenerateAstrobitStarterHouse(int spawnX, int spawnY, bool WaterBolt = false)
		{
			//i = vertical, j = horizontal
			int[,] _structure = {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,4,4,5,5,4,4,4,4,4,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,4,6,6,6,6,6,6,6,6,6,6,4,7,0,1,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,0,4,6,6,6,6,6,6,6,6,6,6,6,6,6,6,4,4,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,4,4,4,4,6,8,8,8,8,6,6,6,6,8,8,8,8,6,6,4,9,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,3,4,6,6,6,8,8,8,10,8,4,4,8,8,8,8,8,8,4,4,4,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,1,0,3,4,6,6,8,8,8,10,0,0,0,12,9,13,0,13,14,8,8,12,9,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,5,4,4,4,6,6,8,8,8,10,13,0,0,0,0,13,13,13,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,3,4,6,6,6,6,6,8,8,8,0,0,0,0,0,13,0,13,0,13,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,1,0,4,4,6,6,6,6,6,6,8,8,4,17,0,0,11,0,0,13,0,13,0,0,15,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1},
				{4,4,4,6,6,6,6,6,6,6,6,8,8,4,4,19,19,19,19,20,20,20,20,19,19,8,8,5,4,21,22,0,18,0,5,4,4,4,4,4,4},
				{6,6,6,6,6,6,6,6,6,6,6,8,8,19,19,19,19,23,24,0,13,13,13,25,26,19,19,4,4,8,8,4,4,4,4,4,6,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,6,6,6,8,25,13,12,13,13,0,0,0,0,13,25,13,0,0,12,28,8,8,8,6,8,6,8,8,6,6,6,6},
				{6,6,6,6,6,6,6,6,4,6,6,8,4,25,29,29,29,13,0,0,0,0,0,25,0,29,30,29,0,26,19,19,4,4,19,19,8,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,6,4,8,4,25,20,20,20,0,13,0,0,0,13,25,13,20,20,20,13,0,12,0,28,13,25,8,8,6,6,6,6},
				{6,6,6,6,4,6,6,6,6,6,6,6,4,25,0,0,0,0,0,0,0,0,0,25,0,13,0,13,0,29,29,13,29,0,25,34,8,6,6,6,6},
				{6,6,6,4,6,6,6,6,6,6,8,6,8,25,0,33,0,0,13,0,27,0,0,25,5,0,0,13,13,20,20,20,20,13,25,8,8,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,6,6,8,8,19,19,19,19,19,19,19,19,4,19,4,4,19,35,0,0,0,13,0,13,13,25,8,6,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,6,6,8,8,8,8,8,8,8,8,8,8,8,8,8,6,19,36,35,0,13,13,0,0,0,25,8,6,6,6,6,6},
				{6,6,6,6,6,6,6,4,6,6,6,6,6,6,8,8,8,8,8,6,8,8,8,6,6,6,19,36,35,13,0,37,0,17,25,8,8,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,4,8,8,8,8,8,8,8,8,6,6,8,19,19,19,4,19,4,4,19,19,8,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,8,8,8,8,8,6,6,8,8,8,8,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,8,8,8,6,8,8,8,6,8,8,6,8,6,6,6,6},
				{6,6,6,6,6,6,6,4,6,6,6,6,6,6,6,6,6,6,6,4,6,6,6,6,6,6,8,8,8,8,8,6,6,8,8,8,8,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,8,6,6,6,6,6,6,6}
			};
			int PosX = spawnX - _structure.GetLength(1) / 2;
			int PosY = spawnY - _structure.GetLength(0) + 15;
			//i = vertical, j = horizontal
			UseStarterHouseHalfCircle(spawnX, spawnY, 0, _structure.GetLength(1) / 2, _structure.GetLength(0));
			for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
			{
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									if (confirmPlatforms == 0)
									{
										tile.active(false);
										tile.halfBrick(false);
										tile.slope(0);
									}
									break;
								case 1:
									if (confirmPlatforms == 1 && !WorldGen.genRand.NextBool(3))
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, TileID.Saplings, true, true, -1, 0);
										WorldGen.GrowTree(k, l);
										WorldGen.GrowEpicTree(k, l);
									}
									break;
								case 3:
									tile.active(true);
									tile.type = 2;
									tile.slope(2);
									tile.halfBrick(false);
									break;
								case 4:
									tile.active(true);
									tile.type = 2;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 5:
									tile.active(true);
									tile.type = 2;
									tile.slope(0);
									tile.halfBrick(true);
									break;
								case 6:
									tile.active(true);
									tile.type = 0;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 7:
									tile.active(true);
									tile.type = 2;
									tile.slope(1);
									tile.halfBrick(false);
									break;
								case 8:
									tile.active(true);
									tile.type = 38;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 9:
									tile.active(true);
									tile.type = 2;
									tile.slope(3);
									tile.halfBrick(false);
									break;
								case 10:
									tile.active(true);
									tile.type = 38;
									tile.slope(3);
									tile.halfBrick(false);
									break;
								case 11:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 101, true, true, -1, 25);
									}
									break;
								case 12:
									tile.active(true);
									tile.type = 373;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 13:
									tile.active(true);
									tile.type = 51;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 14:
									tile.active(true);
									tile.type = 38;
									tile.slope(4);
									tile.halfBrick(false);
									break;
								case 15:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 10, true, true, -1, 30);
									}
									break;
								case 17:
									tile.active(true);
									tile.type = 73;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 18:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 215, true, true, -1, 0);
									}
									break;
								case 19:
									tile.active(true);
									tile.type = 321;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 20:
									if (confirmPlatforms == 0)
										tile.active(false);
									WorldGen.PlaceTile(k, l, 19, true, true, -1, 19);
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 21:
									tile.active(true);
									tile.type = 38;
									tile.slope(0);
									tile.halfBrick(true);
									break;
								case 22:
									tile.active(true);
									tile.type = 38;
									tile.slope(1);
									tile.halfBrick(false);
									break;
								case 23:
									tile.active(true);
									tile.type = 321;
									tile.slope(3);
									tile.halfBrick(false);
									break;
								case 24:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 42, true, true, -1, 5);
									}
									break;
								case 25:
									tile.active(true);
									tile.type = 124;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 26:
									tile.active(true);
									tile.type = 321;
									tile.slope(4);
									tile.halfBrick(false);
									break;
								case 27:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 104, true, true, -1, 6);
									}
									break;
								case 28:
									tile.active(true);
									tile.type = 2;
									tile.slope(4);
									tile.halfBrick(false);
									break;
								case 29:
									if (confirmPlatforms == 1)
										tile.active(false);
									WorldGen.PlaceTile(k, l, TileID.Books, true, true, -1, Main.rand.Next(6));
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 30:
									if (confirmPlatforms == 1)
										tile.active(false);
									WorldGen.PlaceTile(k, l, TileID.Books, true, true, -1, Main.rand.Next(6));
									if (WaterBolt)
										tile.frameX = 90;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 33:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 79, true, true, -1, 24);
									}
									break;
								case 34:
									tile.active(true);
									tile.type = 38;
									tile.slope(2);
									tile.halfBrick(false);
									break;
								case 35:
									if (confirmPlatforms == 0)
										tile.active(false);
									WorldGen.PlaceTile(k, l, 19, true, true, -1, 19);
									tile.slope(1);
									tile.halfBrick(false);
									break;
								case 36:
									tile.active(true);
									tile.type = 321;
									tile.slope(1);
									tile.halfBrick(false);
									break;
								case 37:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, ModContent.TileType<RuinedChestTile>(), true, true, -1, 0);
									}
									break;
								case 38:
									tile.active(true);
									tile.type = 1;
									tile.slope(0);
									tile.halfBrick(false);
									break;
							}
						}
					}
				}
			}
			UseStarterHouseHalfCircle(spawnX, spawnY + 14, 1, _structure.GetLength(1) / 2, 10);
			_structure = new int[,]  {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,3,2,1,1,2,0,0,0,0,0,0,4,1,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,1,1,1,1,1,1,0,0,0,0,2,3,3,3,1,1,1,1,1,1,1,4,4,1,8,8,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,3,3,3,3,3,1,3,1,1,1,1,1,3,8,8,8,0,0,0,0,0,0,0,0,0,0},
				{0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,3,3,3,3,3,3,3,3,1,1,1,1,3,3,8,8,8,8,8,8,8,8,8,8,8,8},
				{1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,3,3,3,3,3,3,3,1,3,3,1,1,1,8,1,1,1,8,8,8,8,8,8,8,8},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,3,3,3,3,2,2,2,0,1,2,1,1,1,1,1,8,8,8,8,8,8,8},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,4,0,3,3,3,3,3,3,3,3,0,0,2,2,6,6,6,6,6,6,6,6,6,6,6,6},
				{0,0,0,0,0,0,0,0,0,0,6,6,0,1,1,1,3,3,3,3,3,3,3,3,3,1,1,1,1,6,6,6,6,6,6,6,6,6,6,6,6},
				{0,0,0,0,0,0,0,0,6,6,6,6,0,1,1,2,3,3,3,3,3,3,3,3,3,3,1,1,1,1,6,6,6,6,6,6,6,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,7,6,6,0,1,1,2,3,3,3,3,3,3,3,3,3,3,1,1,1,3,3,3,1,1,3,6,6,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,6,6,6,0,1,3,3,3,3,3,3,3,3,3,1,1,1,1,1,3,3,3,3,1,1,3,3,6,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,7,6,6,3,3,3,3,3,3,3,3,3,3,1,1,1,1,1,3,3,3,3,3,3,1,3,3,6,6,6,6,6},
				{6,6,6,6,6,6,6,6,7,7,6,6,0,0,0,0,0,0,0,0,4,0,0,0,0,0,1,3,3,3,3,3,3,1,3,3,6,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1,1,3,3,3,3,3,1,3,3,6,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1,1,1,3,3,1,1,1,3,3,6,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1,6,3,3,3,3,3,3,3,3,6,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6},
				{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6}
			};
			for (int i = 0; i < _structure.GetLength(0); i++)
			{
				for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
				{
					int k = PosX + j;
					int l = PosY + i;
					if (WorldGen.InWorld(k, l, 30))
					{
						Tile tile = Framing.GetTileSafely(k, l);
						switch (_structure[i, j])
						{
							case 8:
								tile.wall = 0;
								break;
							case 1:
								tile.wall = 68;
								break;
							case 2:
								tile.wall = 5;
								break;
							case 3:
								tile.wall = 147;
								break;
							case 4:
								tile.wall = 66;
								break;
							case 6:
								tile.wall = 2;
								break;
							case 7:
								tile.wall = 59;
								break;
						}
					}
				}
			}
		}
		public static void GenerateMushnibStarterHouse(int spawnX, int spawnY, bool WaterBolt = false)
		{
			int[,] _structure = {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,2,3,3,3,3,2,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,2,3,3,3,3,2,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,2,3,3,3,3,2,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,2,3,3,3,3,2,0,4,4,0,0,0,0,0,0,0},
				{0,0,0,0,2,3,3,3,3,2,0,4,4,4,4,4,4,0,0,0},
				{0,0,0,0,2,3,3,3,3,2,2,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,2,3,3,3,3,2,4,5,4,4,4,4,5,0,0,0},
				{0,0,0,0,2,3,6,6,3,2,4,5,4,6,6,4,5,0,0,0},
				{0,0,0,0,2,3,6,6,3,2,4,5,4,6,6,4,5,0,0,0},
				{0,0,0,0,2,3,3,3,3,2,4,5,4,4,4,4,5,0,0,0},
				{0,0,0,0,1,1,1,1,1,1,4,1,1,1,1,1,1,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{7,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
				{7,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,8,1,8,0},
				{7,0,9,9,9,8,8,8,4,8,9,8,4,9,8,4,8,9,8,0},
				{7,9,9,10,8,1,1,8,8,8,8,4,8,8,8,8,8,9,8,8},
				{7,7,10,10,10,10,8,8,8,8,8,8,8,8,0,0,0,7,7,7},
				{7,7,10,10,10,10,10,10,10,10,10,10,7,7,7,7,7,7,7,7}
			};
			int PosX = spawnX - _structure.GetLength(1) / 2;
			int PosY = spawnY - _structure.GetLength(0) + 7;
			//i = vertical, j = horizontal
			for (int i = 0; i < _structure.GetLength(0); i++)
			{
				for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
				{
					int k = PosX + j;
					int l = PosY + i;
					if (WorldGen.InWorld(k, l, 30))
					{
						Tile tile = Framing.GetTileSafely(k, l);
						switch (_structure[i, j])
						{
							case 1:
								tile.wall = WallID.MudstoneBrick;
								tile.wallColor(PaintID.Gray);
								break;
							case 2:
								tile.wall = WallID.Ebonwood;
								tile.wallColor(PaintID.Brown);
								break;
							case 3:
								tile.wall = 4;
								break;
							case 4:
								tile.wall = 5;
								break;
							case 5:
								tile.wall = WallID.PinkDungeonSlab;
								tile.wallColor(PaintID.Gray);
								break;
							case 6:
								tile.wall = WallID.MetalFence;
								break;
							case 7:
								tile.wall = 59;
								break;
							case 8:
								tile.wall = 1;
								break;
							case 9:
								tile.wall = 16;
								break;
							case 10:
								tile.wall = 2;
								break;
						}
					}
				}
			}
			_structure = new int[,] {
				{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,2,3,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,1,2,2,3,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,1,2,2,2,2,3,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,1,2,2,2,2,2,2,3,0,0,0,0,0,0,0,0,0},
				{0,0,4,5,2,2,2,2,2,2,5,4,0,0,0,0,0,0,0,0},
				{0,0,5,6,5,5,5,5,5,5,6,5,0,0,0,0,0,0,0,0},
				{0,0,7,6,7,7,7,7,7,7,6,7,0,0,0,0,0,0,0,0},
				{0,0,0,6,0,0,0,8,9,19,6,0,0,0,0,0,0,0,0,0},
				{0,0,0,6,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0},
				{0,0,0,6,0,11,0,0,0,0,6,12,12,12,0,0,0,0,0,0},
				{0,0,0,6,0,0,0,0,0,0,6,5,5,5,12,12,12,12,0,0},
				{0,0,0,6,13,0,0,0,10,0,6,5,5,5,5,5,5,5,5,0},
				{0,0,7,6,7,7,14,14,7,7,6,7,7,7,7,7,7,6,15,0},
				{0,0,0,6,0,0,0,0,0,0,6,0,16,9,18,9,0,6,0,0},
				{0,0,0,6,0,0,0,0,0,0,20,0,21,21,21,21,0,6,0,0},
				{0,0,0,0,0,11,0,0,0,0,20,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,0,0},
				{0,27,0,22,0,0,23,0,24,0,20,0,0,25,0,26,0,22,0,0},
				{28,28,2,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,2,28},
				{29,30,2,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,2,30},
				{30,2,2,0,20,0,0,20,0,0,20,0,0,20,0,0,20,0,0,30},
				{30,30,30,32,20,33,0,20,0,0,20,0,0,20,0,0,20,0,34,30},
				{29,30,30,30,30,30,34,20,0,0,20,0,0,20,35,36,30,30,30,30},
				{29,29,30,30,30,30,30,30,30,30,30,34,34,30,30,30,30,30,30,30},
				{29,29,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,29,30,30}
			};
			//i = vertical, j = horizontal
			UseStarterHouseHalfCircle(spawnX, spawnY - 2, 0, _structure.GetLength(1) / 2, _structure.GetLength(0));
			for (int confirmPlatforms = 0; confirmPlatforms < 3; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
			{
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									if (confirmPlatforms == 0)
									{
										tile.active(false);
										tile.halfBrick(false);
										tile.slope(0);
									}
									break;
								case 1:
									tile.active(true);
									tile.type = 38;
									tile.slope(2);
									tile.halfBrick(false);
									break;
								case 2:
									tile.active(true);
									tile.type = 38;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 3:
									tile.active(true);
									tile.type = 38;
									tile.slope(1);
									tile.halfBrick(false);
									break;
								case 4:
									tile.active(true);
									tile.type = TileID.BlueDynastyShingles;
									tile.color(PaintID.Gray);
									tile.slope(0);
									tile.halfBrick(true);
									break;
								case 5:
									tile.active(true);
									tile.type = TileID.BlueDynastyShingles;
									tile.color(PaintID.Gray);
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 6:
									tile.active(true);
									tile.type = TileID.RichMahogany;
									tile.color(PaintID.Brown);
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 7:
									tile.active(true);
									tile.type = 30;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 8:
									if (confirmPlatforms == 2)
										tile.active(false);
									WorldGen.PlaceTile(k, l, TileID.Bottles, true, true, -1, 0);
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 9:
									if (confirmPlatforms == 2)
										tile.active(false);
									WorldGen.PlaceTile(k, l, TileID.Books, true, true, -1, Main.rand.Next(6));
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 19:
									if (confirmPlatforms == 2)
										tile.active(false);
									WorldGen.PlaceTile(k, l, TileID.Books, true, true, -1, Main.rand.Next(6));
									if (WaterBolt)
										tile.frameX = 90;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 10:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 101, true, true, -1, 5);
									}
									break;
								case 11:
									if (confirmPlatforms == 2)
										tile.active(false);
									WorldGen.PlaceTile(k, l, TileID.Candles, true, true, -1, 1);
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 12:
									tile.active(true);
									tile.type = 38;
									tile.slope(0);
									tile.halfBrick(true);
									break;
								case 13:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 376, true, true, -1, 0);
									}
									break;
								case 14:
									if (confirmPlatforms == 0)
										tile.active(false);
									WorldGen.PlaceTile(k, l, 19, true, true, -1, 0);
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 15:
									tile.active(true);
									tile.type = TileID.BlueDynastyShingles;
									tile.color(PaintID.Gray);
									tile.slope(3);
									tile.halfBrick(false);
									break;
								case 16:
									if (confirmPlatforms == 0)
										tile.active(false);
									WorldGen.PlaceTile(k, l, 13, true, true, -1, 4);
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 18:
									if (confirmPlatforms == 0)
										tile.active(false);
									WorldGen.PlaceTile(k, l, 13, true, true, -1, 3);
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 20:
									tile.active(true);
									tile.type = 124;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 21:
									if (confirmPlatforms == 0)
										tile.active(false);
									WorldGen.PlaceTile(k, l, 19, true, true, -1, 1);
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 22:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 10, true, true, -1, 13);
									}
									break;
								case 23:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 14, true, true, -1, 14);
									}
									break;
								case 24:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 15, true, true, -1, 17);
									}
									break;
								case 25:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 94, true, true, -1, 0);
									}
									break;
								case 26:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, ModContent.TileType<RuinedChestTile>(), true, true, -1, 0);
									}
									break;
								case 27:
									tile.active(true);
									tile.type = 3;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 28:
									tile.active(true);
									tile.type = 2;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 29:
									tile.active(true);
									tile.type = 0;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 30:
									tile.active(true);
									tile.type = 1;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 31:
									tile.active(true);
									tile.type = TileID.Mudstone;
									tile.color(PaintID.Gray);
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 32:
									tile.active(true);
									tile.type = 1;
									tile.slope(1);
									tile.halfBrick(false);
									break;
								case 33:
									if (confirmPlatforms == 0)
										tile.active(false);
									WorldGen.PlaceTile(k, l, 227, true, true, -1, 1);
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 34:
									tile.active(true);
									tile.type = 1;
									tile.slope(0);
									tile.halfBrick(true);
									break;
								case 35:
									if (confirmPlatforms == 0)
										tile.active(false);
									WorldGen.PlaceTile(k, l, 227, true, true, -1, 0);
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 36:
									tile.active(true);
									tile.type = 1;
									tile.slope(2);
									tile.halfBrick(false);
									break;
							}
						}
					}
				}
			}
			UseStarterHouseHalfCircle(spawnX, spawnY + 6, 1, _structure.GetLength(1) / 2, 6);
		}
		public static void FindAndGenerateDamocles(int dungeonSide)
		{
			int third = Main.maxTilesX / 3;
			for (int j = Main.maxTilesY - 200; j > 0; j--)
			{
				int i = 100;
				if (dungeonSide == 1)
				{
					i = Main.maxTilesX - 100;
				}
				bool contin = true;
				bool properGenerate = false;
				int color = 0;
				while (contin)
				{
					if (dungeonSide == 1)
					{
						i--;
						if (i < Main.maxTilesX - third)
						{
							contin = false;
						}
					}
					else
					{
						i++;
						if (i > third)
						{
							contin = false;
						}
					}
					Tile tile = Main.tile[i, j];
					if (Main.tileDungeon[tile.type])
					{
						i += dungeonSide * -16;
						if (tile.type == TileID.GreenDungeonBrick)
							color = 1;
						else if (tile.type == TileID.BlueDungeonBrick)
							color = 2;
						properGenerate = true;
						break;
					}
				}
				if (properGenerate)
				{
					SOTSWorldgenHelper.GenerateDamocles(i, j, color);
					break;
				}
			}
		}
		public static void GenerateDamocles(int spawnX, int spawnY, int type)
		{
			for (int j = 1; j < 30; j++)
			{
				int counter = 0;
				for (int i = -1; i <= 1; i++)
				{
					int tunnel = spawnX + i;
					int tunnelY = spawnY - j;
					Tile tile = Framing.GetTileSafely(tunnel, tunnelY);
					Tile tileAbove = Framing.GetTileSafely(tunnel, tunnelY - 1);
					if ((Main.tileDungeon[tile.type] || TileID.Spikes == tile.type) && tile.active())
					{
						if (Main.tileSolid[tileAbove.type] && !Main.tileSolidTop[tileAbove.type] && tileAbove.active())
							tile.active(false);
						else
						{
							tile.active(false);
							int style = 7;
							if (tile.type == TileID.GreenDungeonBrick)
								style = 8;
							if (tile.type == TileID.BlueDungeonBrick)
								style = 6;
							WorldGen.PlaceTile(tunnel, tunnelY, TileID.Platforms, true, true, -1, style);
						}
						counter++;
					}
				}
				if (counter == 0)
				{
					break;
				}
			}
			int WallType1 = WallID.PinkDungeonUnsafe;
			int WallType2 = WallID.PinkDungeonTileUnsafe;
			int WallType3 = WallID.PurpleStainedGlass;
			int TileType1 = TileID.PinkDungeonBrick;
			int PlatformStyle = 7;
			if (type == 1)
			{
				WallType1 = WallID.GreenDungeonUnsafe;
				WallType2 = WallID.GreenDungeonTileUnsafe;
				WallType3 = WallID.GreenStainedGlass;
				TileType1 = TileID.GreenDungeonBrick;
				PlatformStyle = 8;
			}
			if (type == 2)
			{
				WallType1 = WallID.BlueDungeonUnsafe;
				WallType2 = WallID.BlueDungeonTileUnsafe;
				WallType3 = WallID.BlueStainedGlass;
				TileType1 = TileID.BlueDungeonBrick;
				PlatformStyle = 6;
			}
			int[,] _structure = {
				{0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,2,2,2,2,4,4,4,4,4,2,2,5,3,3,3,3,5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,4,4,4,4,4,4,4,4,4,2,2,5,3,3,3,3,5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,4,5,2,2,2,4,4,4,2,2,2,5,3,3,3,3,5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,4,5,2,2,4,4,4,4,4,2,2,5,3,3,3,3,5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,4,5,2,2,4,6,6,6,4,2,2,5,3,3,3,3,5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,4,5,2,2,6,6,6,6,6,2,2,5,3,3,3,3,5,2,4,7,4,7,7,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,4,5,2,2,6,6,6,6,6,2,2,5,3,3,3,3,5,4,4,7,4,4,7,7,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,4,5,2,2,6,6,6,6,6,2,2,5,3,3,3,3,5,7,7,7,7,7,4,7,5,5,5,5,5,5,5,5,2,2,2,2,0},
				{0,2,2,4,5,2,2,6,6,6,6,6,2,2,5,3,3,3,3,5,4,4,7,4,4,4,7,5,3,3,3,3,3,3,2,2,2,2,2,0},
				{0,2,2,4,5,2,2,6,6,6,6,6,2,2,5,3,3,3,3,5,7,4,7,4,4,4,7,5,3,5,5,5,5,5,5,2,2,2,2,0},
				{0,2,2,4,5,2,2,4,6,6,6,4,2,2,5,3,3,3,3,5,7,7,4,4,4,7,7,5,3,5,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,4,5,2,2,4,4,4,4,4,2,2,5,3,3,3,3,5,2,7,7,7,7,7,5,5,3,5,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,4,5,5,5,4,4,4,4,4,5,5,5,3,3,3,3,5,5,5,4,4,4,5,5,5,3,5,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,4,3,3,3,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,4,4,4,3,3,3,3,5,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,4,4,4,4,4,4,4,4,4,2,2,2,3,3,3,3,5,5,5,5,5,5,5,5,5,5,5,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,2,2,2,2,4,4,4,4,4,2,2,2,3,3,3,3,2,2,2,4,4,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,2,2,2,4,4,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,2,2,2,4,4,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,2,2,2,2,2,2,2,2,2,2,4,4,4,4,2,2,2,2,2,4,4,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,2,2,2,2,2,2,2,2,2,2,4,4,4,4,4,4,4,4,4,4,4,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,2,2,2,2,2,2,2,2,2,2,4,4,4,4,4,4,4,4,4,4,4,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,2,2,2,2,2,2,2,2,2,2,4,4,4,4,4,4,4,4,4,4,4,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
			};
			int PosX = spawnX - 23;  //spawnX and spawnY is where you want the anchor to be when this generates
			int PosY = spawnY;
			//i = vertical, j = horizontal
			for (int i = 0; i < _structure.GetLength(0); i++)
			{
				for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
				{
					int k = PosX + j;
					int l = PosY + i;
					if (WorldGen.InWorld(k, l, 30))
					{
						Tile tile = Framing.GetTileSafely(k, l);
						switch (_structure[i, j])
						{
							case 2:
								tile.wall = (ushort)WallType1;
								break;
							case 3:
								tile.wall = WallID.Shadewood;
								break;
							case 4:
								tile.wall = (ushort)ModContent.WallType<DullPlatingWallWall>();
								break;
							case 5:
								tile.wall = (ushort)WallType2;
								break;
							case 6:
								tile.wall = (ushort)WallType3;
								break;
							case 7:
								tile.wall = WallID.CobaltBrick;
								break;
						}
					}
				}
			}
			_structure = new int[,]  {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,2,2,2,2,2,0,0,3,1,1,1,1,4,0,3,1,1,1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,2,2,2,2,2,2,5,2,2,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,2,1,1,1,1,1,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,0,0,0,0,0,0,0,0},
				{0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0},
				{0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,0,0,0,0,0,0,0},
				{0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,7,7,7,1,4,0,0,0,0,0,0},
				{0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0},
				{0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,8,1,8,1,7,0,0,0,0,0,0},
				{0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,9,9,9,9,9,0,0,0,0,0,0},
				{0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0},
				{0,0,0,2,7,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,0,0,0,0},
				{0,0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,11,1,1,1,0,0,0,0},
				{0,0,0,2,8,1,7,13,1,10,1,13,1,1,7,7,8,1,7,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,4,0,0,0},
				{0,0,0,2,2,2,2,2,5,5,5,2,0,0,0,9,9,9,9,9,9,9,2,2,2,9,9,9,0,1,1,1,1,1,1,1,1,0,0,0},
				{0,0,0,0,0,0,0,2,0,0,0,2,0,0,0,14,16,16,16,16,16,16,2,2,2,16,16,16,16,16,16,16,16,16,16,16,16,0,0,0},
				{0,0,0,0,0,0,0,2,0,0,0,2,0,0,0,0,14,17,17,17,17,17,2,2,2,17,17,17,17,17,17,17,17,17,17,17,17,0,0,0},
				{0,0,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,18,18,17,17,2,2,2,7,17,17,17,7,7,7,17,17,17,17,19,0,0,0},
				{0,0,0,0,0,0,0,2,0,0,0,2,2,2,2,2,2,2,2,2,2,17,2,2,2,0,18,17,1,1,1,1,17,17,7,18,0,0,0,0},
				{0,0,0,0,0,0,0,2,2,2,2,2,2,2,17,17,2,2,2,2,2,17,2,2,2,0,0,14,8,1,8,1,7,19,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,2,2,2,2,2,2,2,20,17,17,17,17,17,17,17,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
			};
			//i = vertical, j = horizontal
			for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
			{
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							if (confirmPlatforms == 0)
							{
								if (_structure[i, j] != 17 && _structure[i, j] != 16)
								{
									tile.liquidType(0);
									tile.liquid = 0;
								}
							}
							switch (_structure[i, j])
							{
								case 0:
									tile.active(true);
									tile.type = (ushort)TileType1;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 1:
									if (confirmPlatforms == 0)
									{
										tile.active(false);
										tile.halfBrick(false);
										tile.slope(0);
									}
									break;
								case 2:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<DullPlatingTile>();
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 3:
									tile.active(true);
									tile.type = (ushort)TileType1;
									tile.slope(3);
									tile.halfBrick(false);
									break;
								case 4:
									tile.active(true);
									tile.type = (ushort)TileType1;
									tile.slope(4);
									tile.halfBrick(false);
									break;
								case 5:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<RoyalGoldBrickTile>();
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 6:
									if (confirmPlatforms == 0)
										tile.active(false);
									else
									{
										WorldGen.PlaceTile(k, l, ModContent.TileType<ArkhalisChainTile>(), true, true, -1, 0);
										tile.frameX = 18;
										tile.slope(0);
										tile.halfBrick(false);
									}
									break;
								case 7:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, TileID.GoldCoinPile, true, true, -1, 0);
									}
									break;
								case 8:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, TileID.FishingCrate, true, true, -1, 5);
									}
									break;
								case 9:
									if (confirmPlatforms == 0)
										tile.active(false);
									WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, PlatformStyle);
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 10:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, (ushort)ModContent.TileType<AncientGoldThroneTile>(), true, true, -1, 0);
									}
									break;
								case 11:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 240, true, true, -1, 17);
									}
									break;
								case 12:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 215, true, true, -1, 7);
									}
									break;
								case 13:
									tile.active(true);
									tile.type = 527;
									tile.slope(0);
									tile.halfBrick(true);
									break;
								case 14:
									tile.active(true);
									tile.type = (ushort)TileType1;
									tile.slope(1);
									tile.halfBrick(false);
									break;
								case 16:
									if (confirmPlatforms == 0)
									{
										tile.active(false);
										tile.halfBrick(false);
										tile.slope(0);
										tile.liquid = 145;
										tile.liquidType(0);
									}
									break;
								case 17:
									if (confirmPlatforms == 0)
									{
										tile.active(false);
										tile.halfBrick(false);
										tile.slope(0);
										tile.liquid = 255;
										tile.liquidType(0);
									}
									break;
								case 18:
									tile.active(true);
									tile.type = (ushort)TileType1;
									tile.slope(0);
									tile.halfBrick(true);
									break;
								case 19:
									tile.active(true);
									tile.type = (ushort)TileType1;
									tile.slope(2);
									tile.halfBrick(false);
									break;
								case 20:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, TileID.Containers, true, true, -1, 17);
									}
									break;
							}
						}
					}
				}
			}
		}
		public static void GenerateIceRuin(int spawnX, int spawnY)
		{
			int[,] _structure = {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,0},
				{0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0},
				{0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
				{0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
				{0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
				{0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
				{0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
				{0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
				{0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0},
				{0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0},
				{0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0},
				{2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2},
				{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2}
			};
			int PosX = spawnX - _structure.GetLength(1) / 2;
			int PosY = spawnY - _structure.GetLength(0) + 16;
			//i = vertical, j = horizontal
			int radius =  36;
			int radiusY = 20;
			float scale = radiusY / (float)radius;
			float invertScale = (float)radius / radiusY;
			for (int x = -radius; x <= radius; x++)
			{
				for (float y = -radius; y <= radius; y += invertScale)
				{
					if (Math.Sqrt(x * x + y * y) <= radius + 0.5)
					{
						int xPosition6 = spawnX + x;
						int yPosition6 = spawnY + (int)(y * scale + 0.5f) - 17;
						Tile tile = Framing.GetTileSafely(xPosition6, yPosition6);
						tile.active(false);
						tile.wall = 0;
					}
				}
			}

			for (int i = 0; i < _structure.GetLength(0); i++)
			{
				for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
				{
					int k = PosX + j;
					int l = PosY + i;
					if (WorldGen.InWorld(k, l, 30))
					{
						Tile tile = Framing.GetTileSafely(k, l);
						switch (_structure[i, j])
						{
							case 0:
								tile.wall = 0;
								break;
							case 1:
								tile.wall = (ushort)ModContent.WallType<HardIceBrickWallWall>();
								break;
							case 2:
								if (tile.active())
									tile.wall = 40;
								break;
						}
					}
				}
			}
			_structure = new int[,] {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,2,2,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,6,5,5,5,5,5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,6,6,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,6,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,6,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,3,3,2,2,2,2,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,1,2,2,2,2,2,4,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,4,0,0,0,0,0},
				{0,0,0,1,2,2,2,2,5,5,5,5,5,2,2,2,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,2,2,2,2,2,5,5,5,5,5,2,2,2,2,2,4,0,0},
				{0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0},
				{0,0,0,0,5,5,5,5,5,6,6,6,5,5,5,5,5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,5,5,5,5,5,0,0,6,6,5,5,5,5,5,0,0,0,0},
				{0,0,0,0,0,0,6,6,6,6,0,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,0,0,0,6,6,6,6,0,0,0,0,0,0},
				{0,0,0,0,0,0,6,6,6,6,0,6,6,0,0,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,0,0,0,0,0,0,6,6,6,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,6,6,0,0,0,6,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,7,0,6,0,0,0,6,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,0,0,0,0,0,0,0,0,0,6,6,6,6,6,0,0,0,0,0,0,0,0,0,6,6,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,6,6,6,0,0,0,0,0,5,5,5,6,6,0,0,0,0,8,0,0,6,6,6,6,5,5,5,0,0,0,0,0,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,6,6,6,6,6,6,6,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0},
				{0,0,0,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,0,0,0},
				{13,13,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,13,13},
				{13,6,6,6,6,5,5,5,6,6,6,6,6,5,5,5,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,5,5,5,6,6,6,6,6,6,5,5,5,6,6,6,6,13},
				{13,6,6,6,6,6,5,6,6,6,6,6,6,6,5,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,5,6,6,6,6,6,6,6,6,5,6,6,6,6,6,13},
				{13,13,9,9,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,13,13,13},
				{13,13,9,9,9,9,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,9,13,13,13},
				{13,13,13,9,9,9,9,9,9,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,9,9,13,13,13},
				{13,13,13,13,13,9,9,9,9,9,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,9,6,6,6,9,6,6,9,6,6,9,9,9,13,13,13},
				{13,13,13,13,13,13,9,9,9,9,9,9,9,9,6,6,6,6,6,6,9,6,6,6,6,6,9,9,6,6,6,6,6,6,6,6,6,9,6,6,9,9,9,6,6,9,9,6,9,6,9,9,13,13,13,13,13},
				{13,13,13,13,13,13,9,9,9,9,9,9,9,9,6,6,6,6,6,6,9,9,6,6,6,6,9,9,6,6,6,6,6,6,6,6,9,9,9,6,9,9,9,9,9,9,9,9,9,9,9,13,13,13,13,13,13},
				{13,13,13,13,13,13,13,13,13,13,9,9,9,9,9,9,9,6,6,6,9,9,9,6,6,9,9,9,6,6,6,6,9,6,6,6,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,13,13,13,13,13,13},
				{13,13,13,13,13,13,13,13,13,13,13,13,9,9,9,9,9,9,6,9,9,9,9,6,9,9,9,9,9,6,6,6,9,9,6,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,13,13,13,13,13,13,13},
				{13,13,13,13,13,13,13,13,13,13,13,13,13,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,6,6,6,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,13,13,13,13,13,13,13,13,13},
				{13,13,13,13,13,13,13,13,13,13,13,13,13,9,9,9,9,9,9,9,9,9,9,9,9,12,12,9,9,9,6,9,9,9,9,9,9,9,9,9,9,9,9,13,13,9,9,13,13,13,13,13,13,13,13,13,13},
				{13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,9,9,9,9,9,13,9,9,9,9,10,12,9,9,9,9,9,9,9,9,9,9,13,13,9,9,9,9,13,13,13,13,13,13,13,13,13,13,13,13,13,13},
				{13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,9,9,9,13,13,13,9,13,9,11,11,11,11,13,13,13,9,9,13,13,13,13,13,13,13,9,9,9,13,13,13,13,13,13,13,13,13,13,13,13,13,13},
				{13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,9,9,9,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,9,13,13,13,13,13,13,13,13,13,13,13,13,13,13},
				{13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,9,9,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13}
			};
			//i = vertical, j = horizontal
			for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
			{
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 1:
									tile.active(true);
									tile.type = 147;
									tile.slope(2);
									tile.halfBrick(false);
									break;
								case 2:
									tile.active(true);
									tile.type = 147;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 3:
									tile.active(true);
									tile.type = 147;
									tile.slope(0);
									tile.halfBrick(true);
									break;
								case 4:
									tile.active(true);
									tile.type = 147;
									tile.slope(1);
									tile.halfBrick(false);
									break;
								case 5:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<HardIceBrickTile>();
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 6:
									if (confirmPlatforms == 0)
									{
										tile.active(true);
										tile.type = (ushort)ModContent.TileType<FrigidIceTile>();
										tile.slope(0);
										tile.halfBrick(false);
										if (i >= 22 && tile.wall == 0)
										{
											tile.wall = (ushort)ModContent.WallType<HardIceBrickWallWall>();
										}
									}
									break;
								case 7:
									if (confirmPlatforms == 0)
										tile.active(false);
									WorldGen.PlaceTile(k, l, 4, true, true, -1, 9);
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 8:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, ModContent.TileType<FrostArtifactTile>(), true, true, -1, 0);
									}
									break;
								case 9:
									if (confirmPlatforms == 0)
									{
										tile.active(true);
										tile.type = 161;
										tile.slope(0);
										tile.halfBrick(false);
										tile.wall = WallID.IceUnsafe;
									}
									else
                                    {
										for(int up = 1; up <= 2; up++)
										{
											Tile tileAbove = Main.tile[k, l - up];
											if (tileAbove.type == ModContent.TileType<FrigidIceTile>() && WorldGen.genRand.NextBool(2 + up))
											{
												tileAbove.type = 161;
											}
										}
                                    }
									break;
								case 10:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, ModContent.TileType<RuinedChestTile>(), true, true, -1, 1);
										tile.wall = (ushort)ModContent.WallType<HardIceBrickWallWall>();
									}
									break;
								case 11:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<CharredWoodTile>();
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 12:
									if (confirmPlatforms == 0)
									{
										tile.active(false);
										tile.halfBrick(false);
										tile.slope(0);
										tile.wall = (ushort)ModContent.WallType<HardIceBrickWallWall>();
									}
									break;
								case 13:
									if(confirmPlatforms == 0 && TrueTileSolid(k, l))
									{
										tile.active(true);
										tile.type = 147;
										tile.slope(0);
										tile.halfBrick(false);
									}
									break;
							}
						}
					}
				}
			}
		}
		public static bool GenerateFrigidIceOre(int spawnX, int spawnY)
		{
			Tile tile = Framing.GetTileSafely(spawnX, spawnY);
			if (!tile.active() || tile.type == TileID.SnowBlock || tile.type == TileID.IceBlock || tile.type == TileID.Slush)
			{
				float rand = Main.rand.NextFloat(2 * (float)Math.PI);
				float interval = Main.rand.NextFloat(24, 32);
				int radius = 8 + Main.rand.Next(4);
				for (int x = -radius; x <= radius; x++)
				{
					for (int y = -radius; y <= radius; y++)
					{
						float noise = Main.rand.NextFloat(0.7f, 1f);
						int xP = spawnX + x;
						int yP = spawnY + y;
						float angle = (float)Math.Atan2(x, y);
						if (Math.Sqrt(x * x + (int)y * (int)y) <= radius + 0.5 && Math.Abs(MathHelper.WrapAngle(angle - rand)) < MathHelper.ToRadians(interval * noise))
						{
							tile = Framing.GetTileSafely(xP, yP);
							if (!tile.active() || tile.type == TileID.SnowBlock || tile.type == TileID.IceBlock || tile.type == TileID.Slush)
								tile.type = (ushort)ModContent.TileType<FrigidIceTile>();
						}
					}
				}
				return true;
			}
			else
				return false;
		}
    }
}