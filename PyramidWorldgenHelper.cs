using Terraria.ID;
using System.Diagnostics;
using Terraria;
using Terraria.ModLoader;
using SOTS.Items.Otherworld;
using Microsoft.Xna.Framework;
using SOTS.Items.Pyramid;
using SOTS.Items.ChestItems;
using System;
using SOTS.Items;

namespace SOTS
{
	public class PyramidWorldgenHelper
	{
		public static void GenerateBossRoom(int spawnX, int spawnY)
        {
			int[,] _structure = {
				{0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,2,0,0,0,2,2,2,0,0,0,0,0,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,2,2,3,2,2,2,0,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,2,2,0,2,3,2,3,2,2,0,2,2,0,2,2,3,3,2,2,2,2,2,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,2,2,0,0,2,2,2,2,2,0,0,2,2,2,2,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,2,2,0,2,3,2,3,3,2,0,2,2,0,2,3,3,3,2,3,3,0,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,0,2,0,2,2,2,2,2,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,2,3,3,3,3,3,3,2,0,0,2,0,2,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,2,3,3,2,2,2,3,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,2,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3,4,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,4,4,4,4,4,4,3,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,3,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,3,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,3,4,4,4,4,4,4,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3,4,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0},
				{0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0},
				{5,5,5,5,5,3,3,3,3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,4,4,4,4,4,4,4,4,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5},
				{5,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,0,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,0,4,3,3,3,3,3,3,3,3,2,4,6,6,4,3,3,3,2,3,3,3,3,0,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5},
				{5,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,0,4,3,3,3,3,3,3,3,2,2,4,6,6,4,2,2,3,2,3,3,2,3,0,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5},
				{5,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,4,0,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,0,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,2,2,4,6,6,4,2,2,2,2,3,3,2,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5},
				{5,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,2,3,3,2,2,4,6,6,4,2,2,2,2,2,2,2,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5},
				{5,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,2,2,2,2,2,4,6,6,4,2,2,2,2,2,2,2,2,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5},
				{5,5,5,5,5,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5},
				{0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0},
				{0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,4,6,6,6,6,6,6,6,6,6,4,6,6,6,6,6,6,6,6,6,4,6,6,6,6,6,6,6,6,6,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,6,6,6,6,6,6,6,6,6,4,6,6,6,6,6,6,6,6,6,4,6,6,6,6,6,6,6,6,6,4,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,4,4,4,6,6,6,6,6,6,6,4,4,4,6,6,6,6,6,6,6,4,4,4,6,6,6,6,6,6,6,4,4,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,4,4,6,6,6,6,6,6,6,4,4,4,6,6,6,6,6,6,6,4,4,4,6,6,6,6,6,6,6,4,4,4,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
			};
			int PosX = spawnX - _structure.GetLength(1)/2;  //spawnX and spawnY is where you want the anchor to be when this generates
			int PosY = spawnY - _structure.GetLength(0)/2;
			//i = vertical, j = horizontal
			for (int i = 0; i < _structure.GetLength(0); i++)
			{
				for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
				{
					int k = PosX + j;
					int l = PosY + i;
					if (WorldGen.InWorld(k, l, 30))
					{
						Tile tile = Framing.GetTileSafely(k, l);
						switch (_structure[i, j])
						{
							case 0:
								if(tile.wall == 0)
									tile.wall = (ushort)ModContent.WallType<PyramidWallTile>();
								break;
							case 1:
								tile.wall = 197;
								break;
							case 2:
								tile.wall = (ushort)ModContent.WallType<CursedTumorWallTile>();
								break;
							case 3:
								tile.wall = (ushort)ModContent.WallType<PyramidWallTile>();
								break;
							case 4:
								tile.wall = 10;
								break;
							case 5:
								tile.wall = (ushort)ModContent.WallType<TrueSandstoneWallWall>();
								break;
							case 6:
								tile.wall = WallID.ArcaneRunes;
								break;
						}
					}
				}
			}
			_structure = new int[,]  {
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,2,2,2,2,3,4,5,2,2,2,2,2,2,2,3,4,4,5,2,2,2,2,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,2,2,2,3,4,4,5,2,2,2,2,2,2,2,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,5,2,2,3,4,4,4,4,5,2,2,2,2,3,4,4,4,4,4,2,2,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,2,2,4,4,4,4,5,2,2,4,4,4,4,5,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,5,2,4,4,4,4,4,4,2,2,2,2,4,4,4,4,4,4,5,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,3,4,4,4,4,4,2,2,4,4,4,4,4,2,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,2,4,4,4,4,4,4,2,2,2,3,4,4,4,4,4,4,4,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,4,4,4,4,4,4,2,3,4,4,4,4,4,2,2,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,2,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,4,4,4,4,4,4,4,2,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3,4,4,4,4,4,4,4,5,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0},
				{0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0},
				{0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0},
				{0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0},
				{0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,8,8,4,4,4,4,4,4,8,8,4,4,4,4,4,8,8,8,4,4,4,4,4,8,8,8,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,8,4,4,4,4,4,4,4,4,4,4,8,8,4,4,4,4,4,4,8,8,8,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0},
				{0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,8,8,8,8,8,8,4,4,8,8,8,8,8,4,4,8,8,8,8,8,8,8,4,8,8,8,8,8,8,4,4,6,4,4,4,7,4,4,6,4,4,4,8,8,8,8,8,8,8,4,4,4,4,8,8,8,8,8,8,8,4,8,8,8,8,8,8,8,8,8,8,8,4,4,4,8,8,8,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0},
				{1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,10,10,10,9,9,9,9,9,9,9,10,10,10,9,9,9,9,9,9,9,10,10,10,9,9,9,9,9,9,9,10,10,10,9,9,9,9,9,9,10,10,10,10,10,10,10,10,9,9,9,9,9,9,10,10,10,9,9,9,9,9,9,9,10,10,10,9,9,9,9,9,9,9,10,10,10,9,9,9,9,9,9,9,10,10,10,9,9,9,9,9,9,9,9,9,9,1,1,1,1,1},
				{4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,11,4,11,4,4,4,4,4,4,4,12,4,12,4,4,4,4,4,4,4,11,4,11,4,4,4,4,4,4,4,12,4,12,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,12,4,12,4,4,4,4,4,4,4,11,4,11,4,4,4,4,4,4,4,12,4,12,4,4,4,4,4,4,4,11,4,11,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4},
				{4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4},
				{4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4},
				{4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,14,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4},
				{4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,13,4,15,4,4,13,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4},
				{1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,2,2,2,2,2,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1},
				{0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,2,2,2,2,2,2,2,2,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0},
				{0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,8,2,2,2,2,2,2,2,16,2,2,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0},
				{0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,8,8,2,2,2,2,2,2,2,16,2,2,2,16,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0},
				{0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,8,8,2,2,2,2,2,2,2,16,2,2,2,2,16,16,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0},
				{0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,8,8,8,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,16,16,2,2,8,8,4,4,4,4,4,4,4,4,4,4,4,4,4,4,14,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0},
				{0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,8,8,8,8,8,8,4,14,8,8,8,4,4,4,14,4,4,4,4,4,4,4,4,8,8,8,8,2,16,16,2,2,2,2,2,16,16,16,16,2,2,2,2,16,16,2,16,8,8,8,8,4,4,4,4,4,4,4,4,4,4,18,18,4,8,8,8,4,4,4,4,4,8,8,8,4,4,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,1,1,1,1,1,4,4,4,4,4,4,8,8,18,4,4,4,4,4,4,18,4,4,18,18,8,4,4,4,4,4,4,4,4,4,8,8,8,8,8,2,16,2,16,16,16,2,2,2,16,16,16,16,16,2,2,2,16,16,16,16,16,8,8,8,8,8,8,4,8,8,4,4,4,18,18,18,18,4,4,4,4,18,8,8,8,8,8,8,8,4,4,4,4,4,4,4,1,1,1,1,1,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,1,1,1,1,1,4,4,8,8,8,8,18,18,17,4,17,4,17,4,18,17,4,18,18,18,8,4,19,4,8,4,20,4,8,8,8,8,8,2,2,16,16,16,2,2,2,2,16,16,16,16,16,16,16,2,2,2,16,16,16,16,16,8,8,8,8,8,8,8,8,8,18,18,18,18,18,18,17,4,17,4,18,18,18,8,8,8,8,8,8,8,8,8,8,4,1,1,1,1,1,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,16,16,16,2,2,2,2,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,16,16,16,2,2,2,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,16,16,16,2,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,16,16,16,16,16,16,16,16,16,16,16,16,16,0,0,16,16,16,16,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,16,16,16,16,16,16,16,16,16,16,16,16,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,16,16,16,16,16,16,16,16,16,16,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,16,16,16,16,16,16,16,16,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,16,16,16,16,16,16,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,16,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
			};
			//i = vertical, j = horizontal
			for (int confirmPlatforms = 0; confirmPlatforms < 4; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
			{
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<PyramidSlabTile>();
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 1:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<TrueSandstoneTile>();
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 2:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<CursedTumorTile>();
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 3:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<CursedTumorTile>();
									tile.slope(3);
									tile.halfBrick(false);
									break;
								case 4:
									if (confirmPlatforms == 0)
									{
										tile.active(false);
										tile.halfBrick(false);
										tile.slope(0);
									}
									break;
								case 5:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<CursedTumorTile>();
									tile.slope(4);
									tile.halfBrick(false);
									break;
								case 6:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 93, true, true, -1, 15);
									}
									break;
								case 7:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, ModContent.TileType<SarcophagusTile>(), true, true, -1, 0);
									}
									break;
								case 8:
									if (confirmPlatforms >= 1 && Main.rand.Next(9) > 1 && !tile.active() && Framing.GetTileSafely(k, l + 1).active())
									{
										tile.active(true);
										tile.type = TileID.GoldCoinPile;
										tile.slope(0);
										tile.halfBrick(false);
									}
									else
									{
										if(tile.type != TileID.GoldCoinPile)
											tile.active(false);
									}
									break;
								case 9:
									if (confirmPlatforms == 0)
										tile.active(false);
									WorldGen.PlaceTile(k, l, 19, true, true, -1, 31);
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 10:
									tile.active(true);
									tile.type = 45;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 11:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 91, true, true, -1, 6);
									}
									break;
								case 12:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 91, true, true, -1, 4);
									}
									break;
								case 13:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 102, true, true, -1, 0);
									}
									break;
								case 14:
									if (confirmPlatforms >= 1)
									{
										if (!tile.active())
										{
											WorldGen.PlaceTile(k, l, TileID.Candelabras, true, true, -1, 15);
										}
									}
									else
                                    {
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
									}
									break;
								case 15:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 18, true, true, -1, 32);
									}
									break;
								case 16:
									tile.active(true);
									tile.type = (ushort)ModContent.TileType<CursedHive>();
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 17:
									if (confirmPlatforms >= 1)
									{
										if(!tile.active())
										{
											WorldGen.PlaceTile(k, l, TileID.FishingCrate, true, true, -1, 2);
											tile.slope(0);
											tile.halfBrick(false);
										}
									}
									else
									{
										tile.active(false);
									}
									break;
								case 18:
									if (confirmPlatforms == 0)
										tile.active(false);
									else if(!tile.active())
									{
										WorldGen.PlaceTile(k, l, TileID.MetalBars, true, true, -1, 6);
										tile.slope(0);
										tile.halfBrick(false);
									}
									break;
								case 19:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 14, true, true, -1, 18);
									}
									break;
								case 20:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										WorldGen.PlaceTile(k, l, 88, true, true, -1, 8);
									}
									break;
							}
						}
					}
				}
			}
		}
		public static bool TileDungeon(Tile tile)
        {
			return tile.type == TileID.BlueDungeonBrick || tile.type == TileID.GreenDungeonBrick || tile.type == TileID.PinkDungeonBrick || tile.wall == 7 || tile.wall == 8 || tile.wall == 9 || tile.wall == 94 || tile.wall == 95 || tile.wall == 96 || tile.wall == 97 || tile.wall == 98 || tile.wall == 99;
		}
		public static void SetTilePyramid(Tile tile)
		{
			tile.type = (ushort)ModContent.TileType<PyramidSlabTile>();
			tile.slope(0);
			tile.halfBrick(false);
			tile.liquidType(0);
			tile.liquid = 0;
			tile.active(true);
		}
		public static void GenerateSOTSPyramid(Mod mod)
        {
			int dungeonSide = -1;
			if (Main.dungeonX > (int)(Main.maxTilesX / 2))
			{
				dungeonSide = 1;
			}
			// -1 = dungeon on left, 1 = dungeon on right
			int pyramidY = -1;
			int pyramidX = -1;
			int checks = 0;
			int xCheck = dungeonSide == 1 ? Main.rand.Next(500, Main.maxTilesX / 2) : Main.rand.Next(Main.maxTilesX / 2, Main.maxTilesX - 500);
			for (; xCheck != -1; xCheck = (dungeonSide == 1 ? Main.rand.Next(500, Main.maxTilesX / 2) : Main.rand.Next(Main.maxTilesX / 2, Main.maxTilesX - 500)))
			{
				for (int ydown = 0; ydown != -1; ydown++)
				{
					Tile tile = Framing.GetTileSafely(xCheck, ydown);
					if (tile.active() && (tile.type == TileID.Sand || tile.type == TileID.Ebonsand || tile.type == TileID.Crimsand || checks >= 1000))
					{
						if ((!WorldGen.UndergroundDesertLocation.Contains(new Point(xCheck, ydown + 60)) && !WorldGen.UndergroundDesertLocation.Contains(new Point(xCheck, ydown + 120))) || checks > 200)
						{
							pyramidY = ydown;
						}
						break;
					}
					else if (tile.active())
					{
						break;
					}
				}
				if (pyramidY != -1)
				{
					pyramidX = xCheck;
					break;
				}
				checks++;
			}
			pyramidY -= 15;
			int direction = Main.rand.Next(2);
			int finalDirection = direction;
			int nextAmount = Main.rand.Next(6, 16);
			int size = 300;
			int endingTileX = -1;
			int endingTileY = -1;
			int initialPath = 1;

			if (Main.maxTilesX > 4000)
				size = 250;

			if (Main.maxTilesX > 6000)
				size = 275;

			if (Main.maxTilesX > 8000)
				size = 300;

			if (direction == 0)
			{
				direction = -1;
			}

			for (int pyramidLevel = 0; pyramidLevel < size; pyramidLevel++)
			{
				for (int h = -pyramidLevel; h <= pyramidLevel; h++)
				{
					Tile tile = Framing.GetTileSafely(pyramidX + h, pyramidY + pyramidLevel);
					if (!TileDungeon(tile)) //check for not dungeon!
					{
						SetTilePyramid(tile);
					}
				}
				for (int h = -pyramidLevel + 1; h <= pyramidLevel - 1; h++)
				{
					Tile tile = Framing.GetTileSafely(pyramidX + h, pyramidY + pyramidLevel);
					if (!TileDungeon(tile)) //check for not dungeon!
					{
						tile.wall = (ushort)mod.WallType("PyramidWallTile");
					}
				}
				if (pyramidLevel >= 10 && pyramidLevel <= 15)
				{
					if (direction == -1)
					{
						for (int g = -pyramidLevel; g <= pyramidLevel - 10; g++)
						{
							Tile tile = Framing.GetTileSafely(pyramidX + g, pyramidY + pyramidLevel);
							if (tile.type == (ushort)mod.TileType("PyramidSlabTile"))
								tile.active(false);
						}
					}
					if (direction == 1)
					{
						for (int g = pyramidLevel; g >= -pyramidLevel + 10; g--)
						{
							Tile tile = Framing.GetTileSafely(pyramidX + g, pyramidY + pyramidLevel);
							if (tile.type == (ushort)mod.TileType("PyramidSlabTile"))
								tile.active(false);
						}
					}
				}
				if (pyramidLevel >= 15 && initialPath == 1)
				{
					if (15 + nextAmount <= pyramidLevel)
					{
						initialPath = -1;
					}
					else
					{
						if (direction == -1)
						{
							for (int g = pyramidLevel - 16; g <= pyramidLevel - 10; g++)
							{
								Tile tile = Framing.GetTileSafely(pyramidX + g, pyramidY + pyramidLevel);
								if (tile.type == (ushort)mod.TileType("PyramidSlabTile"))
									tile.active(false);

							}
							endingTileX = pyramidX + (pyramidLevel - 13);
						}
						if (direction == 1)
						{
							for (int g = -pyramidLevel + 16; g >= -pyramidLevel + 10; g--)
							{
								Tile tile = Framing.GetTileSafely(pyramidX + g, pyramidY + pyramidLevel);
								if (tile.type == (ushort)mod.TileType("PyramidSlabTile"))
									tile.active(false);
							}
							endingTileX = pyramidX + (-pyramidLevel + 13);
						}
					}
					endingTileY = pyramidY + pyramidLevel;
				}
			}
			for (int totalAmount = 0; totalAmount < size; totalAmount += nextAmount)
			{
				direction *= -1;
				nextAmount = Main.rand.Next(6, 31);
				if (totalAmount > size - 230)
				{
					if (endingTileX > pyramidX && endingTileX < pyramidX + 85)
					{
						direction = 1;
						finalDirection = -1;
					}
					if (endingTileX < pyramidX && endingTileX > pyramidX - 85)
					{
						direction = -1;
						finalDirection = 1;
					}
				}
				for (int g = nextAmount; g > 0; g--)
				{
					if (direction == -1)
					{
						endingTileX--;
						for (int h = 3; h >= -3; h--)
						{
							Tile tile = Framing.GetTileSafely(endingTileX + h, endingTileY);
							if (tile.type == (ushort)mod.TileType("PyramidSlabTile"))
								tile.active(false);

						}
						endingTileY++;
					}
					if (direction == 1)
					{
						endingTileX++;
						for (int h = 3; h >= -3; h--)
						{
							Tile tile = Framing.GetTileSafely(endingTileX + h, endingTileY);
							if (tile.type == (ushort)mod.TileType("PyramidSlabTile"))
								tile.active(false);

						}
						endingTileY++;
					}
				}
			}

			//creates cooridors
			int overgrownX = -1;
			int overgrownY = -1;
			int counterL = 0;
			int counterR = 0;
			int counterSpike = 0;
			bool continueCooridor = true;
			for (int fx = -size; fx < size; fx++)
			{
				int findTileX = (fx * -finalDirection) + pyramidX;
				for (int y1 = 2; y1 >= -2; y1--) //top cooridor
				{
					int higherUpY = pyramidY + 30;
					Tile selectTile = Framing.GetTileSafely(findTileX, higherUpY + y1);
					Tile selectTileLeft = Framing.GetTileSafely(findTileX - 1, higherUpY + y1);
					Tile selectTileLeft2 = Framing.GetTileSafely(findTileX - 2, higherUpY + y1);
					Tile selectTileRight = Framing.GetTileSafely(findTileX + 1, higherUpY + y1);
					Tile selectTileRight2 = Framing.GetTileSafely(findTileX + 2, higherUpY + y1);
					if (selectTile.type == (ushort)mod.TileType("PyramidSlabTile") && selectTileLeft.type == (ushort)mod.TileType("PyramidSlabTile") && selectTileLeft2.type == (ushort)mod.TileType("PyramidSlabTile") && selectTileRight.type == (ushort)mod.TileType("PyramidSlabTile") && selectTileRight2.type == (ushort)mod.TileType("PyramidSlabTile"))
					{
						selectTile.active(false);
					}
				}
				int counterInvalid = 0;
				for (int y1 = 2; y1 >= -2; y1--) //zeppelin room and burial room cooridor
				{
					int higherUpY = pyramidY + (size - 40);
					if (!continueCooridor)
					{
						if (overgrownX == -1 && overgrownY == -1)
						{
							overgrownX = findTileX - (26 * finalDirection);
							overgrownY = higherUpY;
						}
						break;
					}
					Tile selectTile = Framing.GetTileSafely(findTileX, higherUpY + y1);
					Tile selectTileLeft = Framing.GetTileSafely(findTileX - 1, higherUpY + y1);
					Tile selectTileLeft2 = Framing.GetTileSafely(findTileX - 2, higherUpY + y1);
					Tile selectTileRight = Framing.GetTileSafely(findTileX + 1, higherUpY + y1);
					Tile selectTileRight2 = Framing.GetTileSafely(findTileX + 2, higherUpY + y1);
					if (!selectTile.active() && !selectTileLeft.active() && !selectTileRight.active() && selectTile.wall == (ushort)mod.WallType("PyramidWallTile") && selectTileLeft.wall == (ushort)mod.WallType("PyramidWallTile") && selectTileRight.wall == (ushort)mod.WallType("PyramidWallTile")) //end the cooridor upon reaching the stairwell
					{
						counterInvalid++;
						if (counterInvalid >= 5)
							continueCooridor = false;
					}
					if (selectTile.type == (ushort)mod.TileType("PyramidSlabTile") && selectTileLeft.type == (ushort)mod.TileType("PyramidSlabTile") && selectTileLeft2.type == (ushort)mod.TileType("PyramidSlabTile") && selectTileRight.type == (ushort)mod.TileType("PyramidSlabTile") && selectTileRight2.type == (ushort)mod.TileType("PyramidSlabTile"))
					{
						selectTile.active(false);
					}
				}
				for (int y1 = 2; y1 >= -2; y1--) //sandslabe cooridor for zepline room
				{
					int higherUpY = pyramidY + (size - 12);
					Tile selectTile = Framing.GetTileSafely(findTileX, higherUpY + y1);
					if (selectTile.type == (ushort)mod.TileType("PyramidSlabTile") && selectTile.active() == true)
					{
						selectTile.type = 274;
					}
				}
				for (int findTileY = pyramidY + (size - 55); findTileY > pyramidY + 10; findTileY--)
				{
					int max = Math.Abs((int)((findTileY - pyramidY) * 0.8f));
					int min = Math.Abs((int)((findTileY - pyramidY) * 0.5f));
					Tile tile = Framing.GetTileSafely(findTileX, findTileY);
					Tile tileLeft = Framing.GetTileSafely(findTileX - 1, findTileY);
					Tile tileRight = Framing.GetTileSafely(findTileX + 1, findTileY);
					if (tile.type == (ushort)mod.TileType("PyramidSlabTile"))
					{
						if (!(findTileY > pyramidY + (size - 70) && finalDirection == 1) && tileLeft.active() && tile.active() && !tileRight.active() && tileRight.wall == (ushort)mod.WallType("PyramidWallTile"))
						{
							//generate cooridor to the left
							counterL++;
							int randDistance = Main.rand.Next(min, max);
							if (Main.rand.Next(3) == 0 && counterL >= 40)
							{
								int coorXPos = findTileX + 2;
								for (int dis = randDistance; dis > 0; dis--)
								{
									for (int y1 = 2; y1 >= -2; y1--)
									{
										Tile selectTile = Framing.GetTileSafely(coorXPos, findTileY + y1);
										Tile selectTileLeft = Framing.GetTileSafely(coorXPos - 1, findTileY + y1);
										Tile selectTileLeft2 = Framing.GetTileSafely(coorXPos - 2, findTileY + y1);
										if (selectTile.type == (ushort)mod.TileType("PyramidSlabTile") && selectTileLeft.type == (ushort)mod.TileType("PyramidSlabTile") && selectTileLeft2.type == (ushort)mod.TileType("PyramidSlabTile"))
										{
											selectTile.active(false);
										}
									}
									coorXPos--;
									counterL = 0;
								}
							}
						}
						if (!(findTileY > pyramidY + (size - 70) && finalDirection == -1) && tileRight.active() && tile.active() && !tileLeft.active() && tileLeft.wall == (ushort)mod.WallType("PyramidWallTile"))
						{
							//generate cooridor to the right
							int randDistance = Main.rand.Next(min, max);
							counterR++;
							if (Main.rand.Next(3) == 0 && counterR >= 40)
							{
								int coorXPos = findTileX - 2;
								for (int dis = randDistance; dis > 0; dis--)
								{
									for (int y1 = 2; y1 >= -2; y1--)
									{
										Tile selectTile = Framing.GetTileSafely(coorXPos, findTileY + y1);
										Tile selectTileRight = Framing.GetTileSafely(coorXPos + 1, findTileY + y1);
										Tile selectTileRight2 = Framing.GetTileSafely(coorXPos + 2, findTileY + y1);
										if (selectTile.type == (ushort)mod.TileType("PyramidSlabTile") && selectTileRight.type == (ushort)mod.TileType("PyramidSlabTile") && selectTileRight2.type == (ushort)mod.TileType("PyramidSlabTile"))
										{
											selectTile.active(false);
										}
									}
									coorXPos++;
									counterR = 0;
								}
							}
						}
						Tile tileUp = Framing.GetTileSafely(findTileX, findTileY - 1);
						Tile tileDown = Framing.GetTileSafely(findTileX, findTileY + 1);
						if (tile.type == (ushort)mod.TileType("PyramidSlabTile") && tile.active() && tileLeft.type == (ushort)mod.TileType("PyramidSlabTile") && tileLeft.active() && tileRight.type == (ushort)mod.TileType("PyramidSlabTile") && tileRight.active() && (!tileUp.active() || !tileDown.active()))
						{
							counterSpike++;
							if (counterSpike >= 40)
							{
								counterSpike = 0;
								for (int sizeSpike = 0; sizeSpike < Main.rand.Next(4, 20); sizeSpike++)
								{
									Tile tileSpikeR = Framing.GetTileSafely(findTileX + sizeSpike, findTileY);
									Tile tileSpikeRU = Framing.GetTileSafely(findTileX + sizeSpike, findTileY - 1);
									Tile tileSpikeRD = Framing.GetTileSafely(findTileX + sizeSpike, findTileY + 1);
									Tile tileSpikeL = Framing.GetTileSafely(findTileX - sizeSpike, findTileY);
									Tile tileSpikeLU = Framing.GetTileSafely(findTileX - sizeSpike, findTileY - 1);
									Tile tileSpikeLD = Framing.GetTileSafely(findTileX - sizeSpike, findTileY + 1);

									if (tileSpikeR.active() && tileSpikeR.type == (ushort)mod.TileType("PyramidSlabTile") && tileSpikeL.active() && tileSpikeL.type == (ushort)mod.TileType("PyramidSlabTile"))
									{
										if (tileSpikeLU.active() == false && tileSpikeLD.active() == true)
										{
											tileSpikeL.type = 232; //wooden spike
										}
										if (tileSpikeRU.active() == false && tileSpikeRD.active() == true)
										{
											tileSpikeR.type = 232; //wooden spike
										}
										if (tileSpikeLU.active() == true && tileSpikeLD.active() == false)
										{
											tileSpikeL.type = 232; //wooden spike
										}
										if (tileSpikeRU.active() == true && tileSpikeRD.active() == false)
										{
											tileSpikeR.type = 232; //wooden spike
										}
									}
									else
									{
										break;
									}
								}
							}
						}
					}
				}
			}
			int bossPosX = pyramidX + ((size - 115) * finalDirection);
			if (finalDirection == 1)
				bossPosX += 1;
			int bossPosY = pyramidY + (size - 40);
			GenerateBossRoom(bossPosX, bossPosY);
			
			bool buildSword = false;
			bool buildPick = false;
			while (!buildPick)
			{
				int findTileY = Main.rand.Next(pyramidY + 40, pyramidY + (size - 70));
				int width = findTileY - pyramidY;
				int findTileX = pyramidX + Main.rand.Next(-width, width + 1);
				int structureWidth = 19;
				int structureHeight = 14;
				int structureRect = structureHeight * structureWidth;
				int count = 0;
				for (int i = 0; i < structureWidth; i++)
				{
					for (int j = 0; j < structureHeight; j++)
					{
						Tile tile = Framing.GetTileSafely(findTileX + i, findTileY + j);
						if (tile.active() && tile.wall == (ushort)mod.WallType("PyramidWallTile") && tile.type == (ushort)mod.TileType("PyramidSlabTile"))
						{
							count++;
						}
					}
				}
				if (count == structureRect)
				{
					buildPick = true;
					GenerateShrineRoom(findTileX, findTileY, mod, 0);
				}
			}
			while (!buildSword)
			{
				int findTileY = Main.rand.Next(pyramidY + 40, pyramidY + (size - 70));
				int width = findTileY - pyramidY;
				int findTileX = pyramidX + Main.rand.Next(-width, width + 1);
				int structureWidth = 19;
				int structureHeight = 14;
				int structureRect = structureHeight * structureWidth;
				int count = 0;
				for (int i = 0; i < structureWidth; i++)
				{
					for (int j = 0; j < structureHeight; j++)
					{
						Tile tile = Framing.GetTileSafely(findTileX + i, findTileY + j);
						if (tile.active() && tile.wall == (ushort)mod.WallType("PyramidWallTile") && tile.type == (ushort)mod.TileType("PyramidSlabTile"))
						{
							count++;
						}
					}
				}
				if (count == structureRect)
				{
					buildSword = true;
					GenerateShrineRoom(findTileX, findTileY, mod, 1);
				}
			}
			float counterRoom = 0;
			for (int findTileY = pyramidY + (size - 70); findTileY > pyramidY + 25; findTileY--)
			{
				counterRoom += 4.25f;
				int width = findTileY - pyramidY;
				if (counterRoom >= 20)
				{
					while (counterRoom > 0)
					{
						int findTileX = pyramidX + Main.rand.Next(-width, width + 1);
						Tile tile = Framing.GetTileSafely(findTileX, findTileY);
						if (tile.active() && tile.wall == (ushort)mod.WallType("PyramidWallTile") && tile.type == (ushort)mod.TileType("PyramidSlabTile"))
						{
							counterRoom--;
							bool canBeLeft = false;
							bool canBeRight = false;
							bool canBeUp = false;
							bool canBeDown = false;
							int tilesLeft = 0;
							int tilesRight = 0;
							int tilesUp = 0;
							int tilesDown = 0;
							int squareCount = 0;
							for (int checkLeft = 0; checkLeft < 80; checkLeft++)
							{
								Tile tileCheck = Framing.GetTileSafely(findTileX - checkLeft, findTileY);
								if (tileCheck.active() == false && tileCheck.wall == (ushort)mod.WallType("PyramidWallTile"))
								{
									tilesLeft = checkLeft;
									break;
								}
								if (tileCheck.active() == true && tileCheck.wall == (ushort)mod.WallType("PyramidWallTile") && tileCheck.type == (ushort)ModContent.TileType<PyramidBrickTile>())
								{
									tilesLeft = -1;
									break;
								}
							}
							for (int checkRight = 0; checkRight < 80; checkRight++)
							{
								Tile tileCheck = Framing.GetTileSafely(findTileX + checkRight, findTileY);
								if (tileCheck.active() == false && tileCheck.wall == (ushort)mod.WallType("PyramidWallTile"))
								{
									tilesRight = checkRight;
									break;
								}
								if (tileCheck.active() == true && tileCheck.wall == (ushort)mod.WallType("PyramidWallTile") && tileCheck.type == (ushort)ModContent.TileType<PyramidBrickTile>())
								{
									tilesRight = -1;
									break;
								}
							}
							for (int checkUp = 0; checkUp < 40; checkUp++)
							{
								Tile tileCheck = Framing.GetTileSafely(findTileX, findTileY - checkUp);
								if (tileCheck.active() == false && tileCheck.wall == (ushort)mod.WallType("PyramidWallTile"))
								{
									tilesUp = checkUp;
									break;
								}
								if (tileCheck.active() == true && tileCheck.wall == (ushort)mod.WallType("PyramidWallTile") && tileCheck.type == (ushort)ModContent.TileType<PyramidBrickTile>())
								{
									tilesUp = -1;
									break;
								}
							}
							for (int checkDown = 0; checkDown < 80; checkDown++)
							{
								Tile tileCheck = Framing.GetTileSafely(findTileX, findTileY + checkDown);
								if (tileCheck.active() == false && tileCheck.wall == (ushort)mod.WallType("PyramidWallTile"))
								{
									tilesDown = checkDown;
									break;
								}
								if (tileCheck.active() == true && tileCheck.wall == (ushort)mod.WallType("PyramidWallTile") && tileCheck.type == (ushort)ModContent.TileType<PyramidBrickTile>())
								{
									tilesDown = -1;
									break;
								}
							}
							for (int checkSquareX = -12; checkSquareX <= 12; checkSquareX++)
							{
								for (int checkSquareY = -12; checkSquareY <= 12; checkSquareY++)
								{
									Tile tileCheck = Framing.GetTileSafely(findTileX + checkSquareX, findTileY + checkSquareY);
									if (tileCheck.type == (ushort)mod.TileType("PyramidSlabTile") && tileCheck.active() && tileCheck.wall == (ushort)mod.WallType("PyramidWallTile"))
									{
										squareCount++;

									}
								}
							}
							if (squareCount >= 625 && tilesDown >= 0 && tilesUp >= 0 && tilesLeft >= 0 && tilesRight >= 0)
							{
								if (tilesRight > tilesDown && tilesRight > tilesUp && tilesRight > tilesLeft)
								{
									canBeRight = true;
								}
								if (tilesLeft > tilesDown && tilesLeft > tilesUp && tilesLeft > tilesRight)
								{
									canBeLeft = true;
								}
								if (tilesDown > tilesUp && tilesDown > tilesLeft && tilesDown > tilesRight)
								{
									canBeDown = true;
								}
								if ((int)(tilesUp * 1.2f) > tilesRight && (int)(tilesUp * 1.2f) > tilesDown && (int)(tilesUp * 1.2f) > tilesLeft) //check this last because of the priority modifications
								{
									canBeUp = true;
								}
							}
							if (canBeRight)
							{
								GeneratePyramidRoom(findTileX, findTileY, 1, mod);
								break;
							}
							if (canBeLeft)
							{
								GeneratePyramidRoom(findTileX, findTileY, 0, mod);
								break;
							}
							if (canBeDown)
							{
								GeneratePyramidRoom(findTileX, findTileY, 3, mod);
								break;
							}
							if (canBeUp)
							{
								GeneratePyramidRoom(findTileX, findTileY, 2, mod);
								break;
							}
						}
					}
				}
			}
			GenerateZepline(pyramidX, pyramidY + (size - 40), mod);

			//rebuild outside of pyramid
			for (int pyramidLevel = 0; pyramidLevel < size; pyramidLevel++)
			{
				for (int h = -pyramidLevel; h <= pyramidLevel; h++)
				{
					Tile tile = Framing.GetTileSafely(pyramidX + h, pyramidY + pyramidLevel);
					if (pyramidLevel >= 20 && h < -pyramidLevel + 2 && h > pyramidLevel - 2)
						if (!TileDungeon(tile)) //check for not dungeon!
						{
							SetTilePyramid(tile);
						}
				}
			}

			if (overgrownX != -1 && overgrownY != -1)
			{
				SOTSWorldgenHelper.GenerateAcediaRoom(overgrownX, overgrownY, mod, finalDirection);
			}

			for (int findTileY = pyramidY + (size - 30); findTileY > pyramidY + 30; findTileY--)
			{
				int width = findTileY - pyramidY;
				for (int t = 0; t < 6; t++)
				{
					int findTileX = pyramidX + Main.rand.Next(-width, width + 1);
					Tile tile = Framing.GetTileSafely(findTileX, findTileY);
					for (int built = 0; built < 2; built++)
					{
						int tileX = findTileX;
						if (tile.wall == (ushort)mod.WallType("PyramidWallTile") && (!tile.active() || Main.rand.Next(size / 3) == 0))
						{
							Tile tile2 = Framing.GetTileSafely(findTileX, findTileY - 3);
							Tile tile3 = Framing.GetTileSafely(findTileX, findTileY + 3);
							if (tile2.active() && tile2.type == (ushort)mod.TileType("PyramidSlabTile") && tile2.wall == (ushort)mod.WallType("PyramidWallTile"))
							{
								if (tile3.active() && tile3.type == (ushort)mod.TileType("PyramidSlabTile") && tile3.wall == (ushort)mod.WallType("PyramidWallTile"))
								{
									GenerateInfection(new Vector2(findTileX * 16, findTileY * 16), mod);
									findTileX += Main.rand.Next(-20, 21);
								}
								else break;
							}
							else break;
						}
						else break;
					}
				}
			}
			for (int findTileY = pyramidY + (size - 30); findTileY > pyramidY + 30; findTileY--)
			{
				for (int findTileX = Main.maxTilesX - 100; findTileX > 100; findTileX--)
				{
					Tile tile = Framing.GetTileSafely(findTileX, findTileY);
					Tile tileU = Framing.GetTileSafely(findTileX, findTileY - 1);
					Tile tileLU = Framing.GetTileSafely(findTileX - 1, findTileY - 1);
					Tile tileU2 = Framing.GetTileSafely(findTileX, findTileY - 2);
					Tile tileLU2 = Framing.GetTileSafely(findTileX - 1, findTileY - 2);
					Tile tileU3 = Framing.GetTileSafely(findTileX, findTileY - 3);
					Tile tileLU3 = Framing.GetTileSafely(findTileX - 1, findTileY - 3);
					if (tile.type == (ushort)mod.TileType("PyramidSlabTile") && !tileLU.active() && !tileLU2.active() && !tileU.active() && !tileU2.active())
					{
						if (Main.rand.Next(5) == 0)
						{
							WorldGen.PlaceTile(findTileX, findTileY - 1, 28, true, true, -1, 3); //pots
						}
						else if (Main.rand.Next(size / 2) == 0)
						{
							if (Main.rand.NextBool(2))
							{
								WorldGen.PlaceTile(findTileX, findTileY - 1, (ushort)ModContent.TileType<CrystalStatue>()); //life crystal
							}
							else
							{
								WorldGen.PlaceTile(findTileX, findTileY - 1, (ushort)ModContent.TileType<ManaStatue>()); //mana crystal
							}
						}
						else if (Main.rand.Next(size / 3) == 0)
						{
							WorldGen.PlaceTile(findTileX, findTileY - 1, (ushort)mod.TileType("PyramidChestTile")); //Chests
						}
						else if (Main.rand.Next((int)(size / 3.5f)) == 0)
						{
							GenerateCrate(findTileX, findTileY - 1, mod);
						}
						else if (!tileU3.active() && !tileLU3.active() && Main.rand.Next(size / 2) == 0)
						{
							WorldGen.PlaceTile(findTileX, findTileY - 1, TileID.Statues, true, true, -1, Main.rand.Next(71)); //random statue
						}
					}
					if (tile.wall == (ushort)mod.WallType("PyramidWallTile") && Main.rand.NextBool(500))
					{
						int radius7 = 3;
						for (int x = -radius7; x <= radius7; x++)
						{
							for (int y = -radius7; y <= radius7; y++)
							{
								int xPosition6 = findTileX + x;
								int yPosition6 = findTileY + y;

								if (Math.Sqrt(x * x + y * y) <= radius7 + 0.5)
								{
									Tile tileRad = Framing.GetTileSafely(xPosition6, yPosition6);
									if (!tileRad.active())
									{
										tileRad.type = 51; //cobweb
										tileRad.active(true);
									}
								}
							}
						}
					}
				}
			}
		}
		public static void GenerateZepline(int spawnX, int spawnY, Mod mod)
        {
			int[,] _zepline = {
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{3,3,3,3,3,3,3,3,3,3,3,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
					{2,2,2,2,2,2,2,2,2,2,3,2,3,3,3,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2},
					{0,0,0,0,0,0,0,3,3,2,3,2,3,3,3,3,3,2,2,2,2,2,2,2,2,2,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2},
					{0,0,0,0,0,0,0,0,3,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,9,9,5,0,0,0,5,9,9,2,2,2,3,2,2,2,2},
					{0,0,0,0,0,0,0,0,0,2,3,3,3,3,3,3,3,2,3,2,3,2,3,2,4,4,4,0,0,0,4,4,4,2,2,3,3,3,2,2,2},
					{0,0,0,0,0,0,0,0,0,2,3,0,0,0,0,0,3,2,3,0,3,0,3,2,2,2,3,0,0,0,3,2,2,2,3,3,0,3,3,2,2},
					{0,0,0,0,0,0,0,0,0,0,3,0,5,9,5,0,3,2,0,0,0,0,0,0,2,2,3,0,0,0,3,2,2,3,3,0,0,0,3,3,2},
					{9,6,0,0,0,0,0,0,0,0,3,0,4,4,4,0,3,0,0,0,0,0,0,0,0,2,2,0,0,0,2,2,3,3,0,0,0,0,0,3,3},
					{3,3,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{2,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,9,9,9,9,9,9,9,3},
					{9,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,3,9,9,9,9,9,3,3},
					{3,3,3,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,3,9,9,9,3,3,2},
					{7,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,3,9,3,3,2,2},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,9,3,2,2,2},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,9,9,2,2,9,2,2,2,2},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,9,6,6,0,1,3,3,3,3,2,2,9,2,2,2,2},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,3,3,8,0,0,1,3,3,3,2,2,9,2,2,2,2},
					{9,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,9,2,2,2,2},
					{3,3,3,3,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,9,9,9,9,9,9,9,9,9,6,2,2,2,2,2,9,2,2,2,2},
					{2,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,6,9,9,9,9,9,6,3,3,2,2,2,2,2,9,2,2,2,2},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,9,3,3,3,3,3,2,2,2,2,2,9,2,2,2,2},
					{0,0,0,0,0,0,6,6,9,9,9,9,9,9,9,9,9,9,9,9,2,2,2,3,3,9,3,3,2,2,2,2,2,2,2,2,9,2,2,2,2},
					{0,0,0,0,0,0,3,3,9,9,9,9,9,9,9,9,9,9,9,9,2,2,2,2,2,9,2,2,2,2,2,2,2,2,2,2,9,2,2,2,2},
					{0,0,0,0,0,0,3,3,9,9,9,9,9,9,9,9,9,9,9,3,3,2,2,2,2,9,9,9,3,3,3,3,3,3,9,9,9,2,2,2,2},
					{9,9,9,9,9,9,9,3,9,9,9,9,9,9,9,9,9,9,9,3,3,2,2,2,2,3,9,9,9,9,9,9,9,9,9,9,9,2,2,2,2},
					{9,9,9,9,9,9,9,3,3,9,9,9,9,9,9,9,9,9,3,3,3,2,2,2,2,3,3,9,9,9,9,9,9,9,9,9,9,2,2,2,2},
					{9,9,9,9,9,9,9,3,3,3,9,9,9,9,9,9,9,3,3,3,2,2,3,3,3,3,3,3,3,9,9,9,9,9,9,9,3,2,2,2,2},
					{9,9,9,9,9,9,9,2,3,3,3,3,9,9,9,3,3,3,3,2,2,2,2,3,3,3,3,3,9,9,9,9,9,9,9,3,3,2,2,2,2},
					{9,9,9,9,9,9,9,2,2,3,3,3,3,9,3,3,3,3,2,2,2,2,2,2,3,3,3,9,9,9,9,9,9,9,3,3,3,2,2,2,2},
					{9,9,9,9,9,9,2,2,2,2,2,2,2,9,2,2,2,2,2,2,2,2,2,2,2,3,9,9,9,9,9,9,9,3,3,3,3,2,2,2,2},
					{9,9,9,9,9,2,2,2,2,2,2,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,3,3,3,3,3,2,2,2,2},
					{9,9,2,2,2,2,2,2,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,3,3,3,3,3,3,2,2,2,2},
					{9,2,2,2,2,2,9,9,9,9,9,9,9,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
					{9,9,9,9,9,9,9,9,9,9,9,9,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
					{9,9,9,9,9,9,9,9,9,9,9,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
					{9,9,9,9,9,9,9,9,9,9,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
					{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
					{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
				};
			int[,] _zeplineWalls = {
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0},
					{0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0},
					{0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,1,1,1,1,1,1,1,1,0,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{2,2,2,0,1,1,1,1,1,1,1,0,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,2,0,1,1,1,1,1,1,1,0,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,2,0,1,1,1,1,1,1,1,0,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,2,0,1,1,1,1,1,1,1,0,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,2,0,1,1,1,1,1,1,1,0,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,2,0,1,1,1,1,1,1,1,0,2,2,2,0,1,1,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,2,0,1,1,1,1,1,1,1,0,2,2,2,0,1,1,1,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{2,2,2,2,0,1,1,1,1,1,1,0,2,2,2,0,1,1,1,0,0,0,0,0,0,0,0,2,2,2,0,2,0,0,0,0,0,0,0,0,0},
					{0,0,0,2,0,1,1,1,1,1,1,0,2,2,2,0,1,1,1,0,0,0,0,0,0,0,0,2,2,2,0,2,0,0,0,0,0,0,0,0,0},
					{0,0,0,2,0,1,1,1,1,1,1,0,2,2,2,0,1,1,1,0,0,0,0,0,0,0,0,2,2,2,0,2,0,0,0,0,0,0,0,0,0},
					{0,0,0,2,0,1,1,1,1,1,1,0,2,2,2,0,1,1,1,0,0,0,0,0,0,0,0,2,2,2,0,2,0,0,0,0,0,0,0,0,0},
					{0,0,0,2,0,1,1,1,1,1,1,0,2,2,2,0,1,1,1,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0},
					{0,0,0,2,0,1,1,1,1,1,1,0,2,2,2,0,1,1,1,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,2,0,1,1,1,1,1,1,0,2,2,2,0,1,1,1,0,0,0,0,2,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{2,2,2,2,2,0,1,1,1,1,1,0,2,2,2,0,1,1,1,1,0,0,0,2,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,2,0,1,1,1,1,1,0,2,2,2,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,2,0,1,1,1,1,1,0,2,2,2,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,2,0,1,1,1,1,1,0,2,2,2,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
					{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
				};

			int pyramidPosX = spawnX;
			int pyramidPosY = spawnY;
			pyramidPosY -= (int)(.5f * _zepline.GetLength(0)) - 10;

			for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
			{
				for (int y = 0; y < _zepline.GetLength(0); y++)
				{
					for (int x = 0; x < _zepline.GetLength(1); x++)
					{
						int k = pyramidPosX + x;
						int l = pyramidPosY + y;
						int k2 = pyramidPosX - x;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							Tile tile2 = Framing.GetTileSafely(k2, l);
							switch (_zepline[y, x])
							{
								case 0:
									if (tile.type == (ushort)mod.TileType("PyramidSlabTile"))
										tile.active(false);

									if (tile2.type == (ushort)mod.TileType("PyramidSlabTile"))
										tile2.active(false);
									break;
								case 1:
									tile.type = 274;
									tile.active(true);
									tile.slope(4);
									tile2.type = 274;
									tile2.active(true);
									tile2.slope(3);
									break;
								case 2:
									tile.type = (ushort)mod.TileType("PyramidSlabTile");
									tile.active(true);
									tile.slope(0);
									tile.halfBrick(false);
									tile2.type = (ushort)mod.TileType("PyramidSlabTile");
									tile2.active(true);
									tile2.slope(0);
									tile2.halfBrick(false);
									break;
								case 3:
									tile.type = 274; //sandstone slab
									tile.active(true);
									tile.slope(0);
									tile.halfBrick(false);
									tile2.type = 274;
									tile2.active(true);
									tile2.slope(0);
									tile2.halfBrick(false);
									break;
								case 4:
									tile.type = 326; //waterfall
									tile.active(true);
									tile.slope(0);
									tile.halfBrick(false);

									tile2.type = 326; //waterfall
									tile2.active(true);
									tile2.slope(0);
									tile2.halfBrick(false);
									break;
								case 5:
									tile.type = 326; //waterfall
									tile.active(true);
									tile.halfBrick(true);
									tile2.type = 326; //waterfall
									tile2.active(true);
									tile2.halfBrick(true);
									break;
								case 6:
									tile.type = 274;
									tile.active(true);
									tile.halfBrick(true);
									tile2.type = 274;
									tile2.active(true);
									tile2.halfBrick(true);
									break;
								case 7:
									tile.type = (ushort)mod.TileType("ZeplineLureTile");
									tile.slope(0);
									tile.halfBrick(false);
									tile.active(true);
									break;
								case 8:
									tile.type = 274;
									tile.active(true);
									tile.slope(3);
									tile2.type = 274;
									tile2.active(true);
									tile2.slope(4);
									break;
								case 9:
									tile.liquidType(0);
									tile.liquid = 255;
									tile.active(false);
									WorldGen.SquareTileFrame(k, l, false);

									tile2.liquidType(0);
									tile2.liquid = 255;
									tile2.active(false);
									WorldGen.SquareTileFrame(k2, l, false);
									break;
							}
						}
					}
				}
			}
			for (int y = 0; y < _zeplineWalls.GetLength(0); y++)
			{
				for (int x = 0; x < _zeplineWalls.GetLength(1); x++)
				{
					int k = pyramidPosX + x;
					int l = pyramidPosY + y;
					int k2 = pyramidPosX - x;
					if (WorldGen.InWorld(k, l, 30))
					{
						Tile tile = Framing.GetTileSafely(k, l);
						Tile tile2 = Framing.GetTileSafely(k2, l);
						switch (_zeplineWalls[y, x])
						{
							case 0:
								tile.wall = (ushort)mod.WallType("PyramidWallTile");  //sandbrick
								tile2.wall = (ushort)mod.WallType("PyramidWallTile");
								break;
							case 1:
								tile.wall = 226; //sandfall 
								tile2.wall = 226;
								break;
							case 2:
								tile.wall = 136; //waterfall
								tile2.wall = 136;
								break;
							case 3:
								break;
							case 4:
								break;
						}
					}
				}
			}
		}
		public static void GenerateCrate(int x, int y, Mod mod)
		{
			int rand = Main.rand.Next(4);
			if (rand != 3)
			{
				WorldGen.PlaceTile(x, y, 376, true, true, -1, rand);
			}
			else
			{
				WorldGen.PlaceTile(x + 1, y, mod.TileType("PyramidCrateTile"));
			}
		}
		public static void GenerateShrineRoom(int x, int y, Mod mod, int type = 0)
		{
			int[,] _structure = {
				{0,0,0,0,0,0,0,1,1,12,1,1,0,0,0,0,0,0,0},
				{0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,2,2,0,0},
				{0,0,2,1,1,1,1,1,3,4,3,1,1,1,1,1,2,0,0},
				{0,1,2,4,3,1,1,1,5,2,6,1,1,1,3,4,2,1,0},
				{1,1,5,2,6,1,1,1,1,1,1,1,1,1,5,2,6,1,1},
				{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
				{1,1,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1},
				{8,8,8,8,8,8,8,4,13,13,13,4,8,8,8,8,8,8,8},
				{0,2,8,8,8,10,10,10,10,10,10,10,10,10,8,8,8,2,0},
				{0,2,2,8,8,9,4,4,4,4,4,4,4,11,8,8,2,2,0},
				{0,0,2,2,8,8,8,9,4,4,4,11,8,8,8,2,2,0,0},
				{0,0,0,2,2,8,8,8,8,8,8,8,8,8,2,2,0,0,0},
				{0,0,0,0,2,2,2,8,8,8,8,8,2,2,2,0,0,0,0}
			};
			int PosX = x;  //spawnX and spawnY is where you want the anchor to be when this generates
			int PosY = y;
			//i = vertical, j = horizontal
			for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
			{
				for (int i = 0; i < _structure.GetLength(0); i++)
				{
					for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
					{
						int k = PosX + j;
						int l = PosY + i;
						if (WorldGen.InWorld(k, l, 30))
						{
							Tile tile = Framing.GetTileSafely(k, l);
							switch (_structure[i, j])
							{
								case 0:
									tile.active(true);
									tile.type = (ushort)mod.TileType("PyramidSlabTile");
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 1:
									if (confirmPlatforms == 0)
									{
										tile.active(false);
										tile.halfBrick(false);
										tile.slope(0);
									}
									break;
								case 2:
									tile.active(true);
									tile.type = 274;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 3:
									tile.active(true);
									tile.type = 274;
									tile.slope(0);
									tile.halfBrick(true);
									break;
								case 4:
									if (confirmPlatforms == 0)
									{
										tile.active(false);
										tile.halfBrick(false);
										tile.slope(0);
										tile.liquid = 255;
										tile.liquidType(0);
									}
									break;
								case 5:
									tile.active(true);
									tile.type = 274;
									tile.slope(4);
									tile.halfBrick(false);
									break;
								case 6:
									tile.active(true);
									tile.type = 274;
									tile.slope(3);
									tile.halfBrick(false);
									break;
								case 7:
									if (confirmPlatforms == 1)
									{
										tile.active(false);
										tile.slope(0);
										tile.halfBrick(false);
										if (type == 0)
											WorldGen.PlaceTile(k, l, mod.TileType("EnchantedSwordShrineTile"), true, true, -1, 0);

										if (type == 1)
											WorldGen.PlaceTile(k, l, mod.TileType("EnchantedPickShrineTile"), true, true, -1, 0);
									}
									break;
								case 8:
									tile.active(true);
									tile.type = 2;
									tile.slope(0);
									tile.halfBrick(false);
									break;
								case 9:
									tile.active(true);
									tile.type = 2;
									tile.slope(1);
									tile.halfBrick(false);
									break;
								case 10:
									if (confirmPlatforms == 0)
									{
										tile.active(false);
										tile.halfBrick(false);
										tile.slope(0);
										tile.liquid = 254;
										tile.liquidType(0);
									}
									break;
								case 11:
									tile.active(true);
									tile.type = 2;
									tile.slope(2);
									tile.halfBrick(false);
									break;
								case 12:
									if (confirmPlatforms == 0)
									{
										tile.active(false);
										tile.halfBrick(false);
										tile.slope(0);
										for (int h = 1; h < 50; h++)
										{
											Tile tile2 = Framing.GetTileSafely(k, l - h);
											Tile tile3 = Framing.GetTileSafely(k, l - h - 1);
											Tile tile4 = Framing.GetTileSafely(k, l - h - 2);
											Tile tile5 = Framing.GetTileSafely(k, l - h - 3);
											if (tile2.type == mod.TileType("PyramidSlabTile") && tile2.active() && tile3.type == mod.TileType("PyramidSlabTile") && tile3.active() && tile4.type == mod.TileType("PyramidSlabTile") && tile4.active() && tile5.type == mod.TileType("PyramidSlabTile") && tile5.active())
											{
												if (Main.rand.Next(h) <= Main.rand.Next(50))
												{
													tile2.active(false);
													tile2.halfBrick(false);
													tile2.slope(0);
												}
											}
											else
											{
												break;
											}
										}
									}
									break;
								case 13:
									tile.active(true);
									tile.type = (ushort)mod.TileType("CursedHive");
									tile.slope(0);
									tile.halfBrick(false);
									break;
							}
						}
					}
				}
			}
		}
		public static bool CanTunnelTile(Tile tile)
        {
			return !tile.active() ||
				tile.wall != (ushort)ModContent.WallType<PyramidWallTile>() ||
				(tile.type != (ushort)ModContent.TileType<PyramidSlabTile>() &&
				tile.type != TileID.SandStoneSlab &&
				tile.type != (ushort)ModContent.TileType<PyramidBrickTile>());
		}
		public static bool StopTunnelTile(Tile tile)
		{
			return tile.active() && (tile.type == (ushort)ModContent.TileType<TrueSandstoneTile>() || tile.type == (ushort)ModContent.TileType<CursedTumorTile>());
		}
		public static void GeneratePyramidRoom(int x, int y, int direction, Mod mod)
		{
			//direction 0 = left, 1 = right, 2 = up, 3 = down
			if (direction == 0 || direction == 1 || direction == 2 || direction == 3)
			{
				for (int checkSquareX = -12; checkSquareX <= 12; checkSquareX++)
				{
					for (int checkSquareY = -12; checkSquareY <= 12; checkSquareY++)
					{
						Tile tileCheck = Framing.GetTileSafely(x + checkSquareX, y + checkSquareY);
						if (checkSquareX == -12 || checkSquareX == 12 || checkSquareY == -12 || checkSquareY == 12)
						{
							tileCheck.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstoneBrick
						}
						if (checkSquareX == -10 || checkSquareX == 10 || checkSquareY == -10 || checkSquareY == 10)
						{
							tileCheck.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstoneBrick
						}
					}
				}
				Tile initialTile = Framing.GetTileSafely(x, y);
				int variation = WorldGen.genRand.Next(12);
				if (direction == 0)
				{
					//tile.type = 200;
					if (Main.rand.Next(2) != 0)
					{
						for (int checkLeft = 0; checkLeft < 300; checkLeft++)
						{
							int check5 = 0;
							for (int h = 2; h >= -2; h--)
							{
								Tile checkTile = Framing.GetTileSafely(x - checkLeft, y + h);
								if (CanTunnelTile(checkTile))
								{
									check5++;
								}
								if(StopTunnelTile(checkTile))
                                {
									check5 = 5;
								}
								else
									checkTile.active(false);
							}
							if (check5 >= 5)
							{
								break;
							}
						}
					}
					if (variation == 0)
					{
						int[,] _pyramidRoom = {
							{1,1,1,1,1,1,7,7,3,3,3,3,3,3,3,3,3},
							{1,7,7,7,7,7,7,7,0,0,4,8,8,3,3,3,3},
							{1,7,7,7,7,7,0,0,0,0,3,3,3,3,3,3,3},
							{1,7,7,0,0,0,0,0,0,0,0,0,4,8,8,3,3},
							{1,1,7,7,0,0,0,0,0,0,0,0,3,3,3,3,3},
							{2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3},
							{2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3},
							{1,1,1,1,1,1,8,8,8,8,8,8,8,3,3,3,3},
							{1,8,8,8,8,8,8,8,8,8,8,8,8,8,3,3,3},
							{1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,3,3},
							{1,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,3},
							{1,1,8,5,8,8,8,8,6,8,8,8,8,8,8,8,8}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.halfBrick(true);
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, Main.rand.Next(71)); //random statue
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 8:
												tile.liquidType(0);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 1)
					{
						int[,] _pyramidRoom = {
							{1,1,1,1,1,7,0,0,0,0,0,7,1,1,1,1,1},
							{1,2,1,7,7,0,0,0,0,0,0,0,7,7,1,2,1},
							{1,1,7,0,0,0,0,0,0,0,0,0,0,0,7,1,1},
							{1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1},
							{1,7,0,0,0,0,0,7,0,7,0,0,0,0,0,7,1},
							{7,0,0,0,0,0,0,7,2,7,0,0,0,0,0,0,7},
							{0,0,0,0,0,0,2,7,7,7,2,0,0,0,0,0,0},
							{0,0,0,0,7,7,7,1,1,1,7,7,7,0,0,9,9},
							{0,0,0,0,0,2,7,1,0,1,7,2,0,0,0,6,9},
							{0,0,0,0,7,7,7,1,1,1,7,7,7,0,0,3,3},
							{0,0,0,0,0,0,2,7,7,7,2,0,0,0,0,0,3},
							{7,0,0,0,0,0,0,7,2,7,0,0,0,0,0,0,7},
							{1,7,0,0,0,0,0,7,0,7,0,0,0,0,0,7,1},
							{1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1},
							{1,1,7,0,0,0,0,0,0,0,0,0,0,0,7,1,1},
							{1,2,1,7,7,0,0,0,0,0,0,0,7,7,1,2,1},
							{1,1,1,1,1,7,0,0,0,0,0,7,1,1,1,1,1}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.halfBrick(true);
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, Main.rand.Next(71)); //random statue
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 232; //woodenspike
												tile.active(true);
												break;
											case 8:
												tile.liquidType(0);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 2)
					{
						int[,] _pyramidRoom = {
							{1,1,1,1,1,1,3,1,1,1,1,1,1,3,1,1,1},
							{1,0,0,0,0,0,3,0,0,0,0,3,3,3,3,3,0},
							{1,0,0,0,3,3,3,3,3,0,0,3,1,1,1,3,0},
							{1,0,0,0,3,1,1,1,3,0,0,0,1,1,1,0,0},
							{1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0},
							{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1},
							{0,0,0,0,0,0,5,0,0,0,0,3,3,3,3,3,0},
							{0,0,0,1,1,1,1,1,1,0,0,0,3,0,0,0,0},
							{3,0,0,0,3,3,3,3,0,0,0,0,3,0,3,0,0},
							{3,0,0,0,0,0,3,0,0,3,8,8,8,8,3,0,0},
							{3,8,8,8,3,0,3,0,0,3,8,8,8,8,3,8,3},
							{3,8,8,8,3,8,8,8,8,3,8,8,8,8,3,8,3},
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.halfBrick(true);
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 16); //anvil
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 302); //glass kiln
												break;
											case 7:
												tile.type = 232; //woodenspike
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(true);
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 3)
					{
						int[,] _pyramidRoom = {
							{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0},
							{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
							{0,0,0,3,3,3,3,3,3,3,3,3,3,3,0,0,0},
							{0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0},
							{0,0,0,0,0,3,3,3,3,3,3,3,0,0,0,0,0},
							{0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,7,0},
							{0,0,0,0,0,0,0,3,3,3,0,0,0,3,3,3,3},
							{0,0,0,0,0,0,2,2,2,2,2,0,0,0,2,2,3},
							{0,0,0,0,0,3,3,3,3,3,3,3,0,0,0,0,3},
							{0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0},
							{0,0,0,3,3,3,3,3,3,3,3,3,3,3,0,0,0},
							{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
							{0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.halfBrick(true);
												tile.active(true);
												break;
											case 5:
												tile.active(true);
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 16); //anvil
												break;
											case 7:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("CrystalStatue")); //heart crystal
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(true);
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 4)
					{
						int[,] _pyramidRoom = {
							{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
							{1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
							{1,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{1,3,5,0,5,0,0,0,0,0,0,0,0,0,0,0,0},
							{1,9,9,9,9,9,9,0,0,0,0,0,0,0,0,4,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4},
							{0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4},
							{0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3},
							{0,0,0,0,0,0,0,0,4,0,3,3,3,3,3,3,3},
							{0,0,0,0,0,0,0,0,4,4,3,3,3,3,3,3,3},
							{0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2},
							{0,0,0,0,0,4,4,0,3,3,3,3,3,3,3,3,3},
							{0,0,0,0,4,4,4,4,3,3,3,3,3,3,3,3,3},
							{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												GenerateCrate(k, l, mod); //crates
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 16); //anvil
												break;
											case 7:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("CrystalStatue")); //heart crystal
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 5)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,2,3,3,3,3,3,2,3,3,3,3,3},
							{3,6,6,6,6,2,1,1,1,1,1,2,6,6,6,6,3},
							{3,0,6,0,6,6,6,6,6,6,6,6,6,0,6,0,3},
							{3,0,0,0,6,0,0,0,6,0,0,0,6,0,0,0,3},
							{3,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,3},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0},
							{3,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,3},
							{3,0,0,0,6,0,0,0,2,0,0,0,6,0,0,0,3},
							{3,0,6,0,6,6,6,6,2,6,6,6,6,0,6,0,3},
							{3,6,6,6,6,2,1,1,1,1,1,2,6,6,6,6,3},
							{3,3,3,3,3,2,3,3,3,3,3,2,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												GenerateCrate(k, l, mod); //crates
												break;
											case 6:
												tile.type = 232; //wooden spike
												tile.active(true);
												break;
											case 7:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 6)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,3,3,3,2,2,2,2,2,3,3,3,0,0,3},
							{3,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,3},
							{0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0},
							{0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,4,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0},
							{0,0,0,3,7,7,7,7,0,7,7,7,7,3,0,0,0},
							{3,0,0,3,7,7,7,7,7,7,7,7,7,3,0,0,3},
							{3,0,0,3,3,3,2,2,2,2,2,3,3,3,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 219); //extractinator
												break;
											case 5:
												tile.type = 232; //spike
												tile.active(true);
												break;
											case 6:
												tile.active(false);
												GenerateCrate(k, l, mod); //crates
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 7)
					{
						int[,] _pyramidRoom = {
							{1,1,1,1,5,5,0,0,0,0,0,5,5,1,1,1,1},
							{1,1,5,5,5,0,0,0,0,0,0,0,5,5,5,1,1},
							{1,5,5,5,0,0,0,0,0,0,0,0,0,5,5,5,1},
							{5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5},
							{5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5},
							{0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,3,3,3,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,3,3,3,3,3,0,0,0,0,0,0},
							{0,0,0,0,0,3,3,3,3,3,3,3,8,8,8,8,8},
							{0,0,0,0,3,3,3,3,3,3,3,3,3,8,8,8,8},
							{0,0,0,3,3,3,3,3,3,3,3,3,3,3,8,8,8},
							{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2},
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
							{3,3,2,3,2,0,3,2,2,2,3,0,2,3,2,3,3},
							{3,3,2,3,0,0,3,2,0,2,3,0,0,3,2,3,3},
							{3,3,2,3,6,0,3,2,2,2,3,6,0,3,2,3,3},
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("CrystalStatue")); //heart crystal
												break;
											case 7:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(true);
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 8)
					{
						int[,] _pyramidRoom = {
							{5,5,5,2,1,3,0,0,0,0,0,3,1,2,5,5,5},
							{5,0,5,2,1,3,0,0,0,0,0,3,1,2,5,0,5},
							{5,5,5,2,2,3,0,0,0,0,0,3,2,2,5,5,5},
							{2,2,2,1,1,3,0,0,0,0,0,3,1,1,2,2,2},
							{1,1,2,1,3,0,0,0,0,0,0,0,3,1,2,1,1},
							{3,3,3,3,0,0,0,0,0,0,0,0,0,3,3,3,3},
							{0,0,0,0,0,0,0,5,5,5,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,5,1,1,1,5,0,0,0,0,0,0},
							{0,0,0,0,0,0,5,1,3,1,5,0,0,0,0,0,0},
							{0,0,0,0,0,0,5,1,1,1,5,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,5,5,5,0,0,0,0,7,0,0},
							{3,3,3,3,0,0,0,0,0,0,0,0,0,3,3,3,3},
							{1,1,2,1,3,0,0,0,0,0,0,0,3,1,2,0,0},
							{2,2,2,1,1,3,0,0,0,0,0,3,1,1,2,2,2},
							{5,5,5,2,2,3,0,0,0,0,0,3,2,2,5,5,5},
							{5,0,5,2,1,3,0,0,0,0,0,3,0,2,5,0,5},
							{5,5,5,2,1,3,0,0,0,0,0,3,0,2,5,5,5}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.type = 232; //wooden spike
												tile.active(true);
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("CrystalStatue")); //heart crystal
												break;
											case 7:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(true);
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 9)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
							{3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3},
							{3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3},
							{3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3},
							{0,5,4,4,4,4,4,4,4,4,4,4,4,4,4,4,3},
							{0,0,5,4,4,4,4,4,4,4,4,4,4,4,4,4,3},
							{0,0,0,5,4,4,4,4,4,4,4,4,4,4,4,4,3},
							{0,0,0,0,5,4,4,4,4,4,4,4,4,4,4,4,3},
							{0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,3},
							{0,0,0,0,0,5,4,4,4,4,4,4,4,4,4,4,3},
							{0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,3},
							{0,0,0,0,0,0,5,4,2,2,2,2,2,2,2,2,2},
							{3,0,0,0,0,0,0,4,2,3,3,3,3,3,3,3,3},
							{2,2,0,0,0,0,0,4,2,0,0,0,0,0,0,0,0},
							{3,3,3,0,0,0,0,5,3,0,0,0,0,0,0,0,0},
							{2,2,2,2,0,0,0,0,3,0,0,0,0,0,0,0,0},
							{3,3,3,3,3,0,0,0,3,0,0,0,0,6,0,7,0}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 53; //sand
												tile.active(true);
												break;
											case 5:
												tile.type = 53; //sand
												tile.active(true);
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("CrystalStatue")); //heart crystal
												break;
											case 7:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(true);
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 10)
					{
						int[,] _structure = {
							{0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0},
							{0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0},
							{0,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0},
							{0,0,1,0,0,0,0,0,2,3,2,0,0,0,1,0,0},
							{0,0,1,0,0,0,0,0,0,2,0,0,0,0,1,0,0},
							{0,2,3,2,0,0,0,0,0,0,0,0,0,0,1,0,0},
							{0,0,2,0,0,0,0,0,4,0,0,0,0,2,3,2,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0},
							{0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0},
							{10,0,0,0,0,0,0,8,0,12,10,10,9,0,13,14,10},
							{10,10,0,11,0,13,13,14,14,10,10,10,14,14,14,10,10},
							{10,10,10,14,14,14,14,14,10,10,10,10,15,14,15,15,10},
							{10,15,15,15,14,15,15,15,15,15,15,15,15,15,15,15,10}
						};
						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _structure.GetLength(1));
						PosY -= (int)(.5f * _structure.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
						{
							for (int i = 0; i < _structure.GetLength(0); i++)
							{
								for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_structure[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
												{
													tile.active(false);
													tile.halfBrick(false);
													tile.slope(0);
												}
												break;
											case 1:
												tile.active(true);
												tile.type = 213;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 2:
												tile.active(true);
												tile.type = 232;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 3:
												tile.active(true);
												tile.type = (ushort)mod.TileType("PyramidSlabTile");
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 4:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, 241, true, true, -1, 8);
												}
												break;
											case 5:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, 241, true, true, -1, 1);
												}
												break;
											case 6:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, 241, true, true, -1, 0);
												}
												break;
											case 7:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile"), true, true, -1, 0);
												}
												break;
											case 8:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, 85, true, true, -1, 2);
												}
												break;
											case 9:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, 85, true, true, -1, 8);
												}
												break;
											case 10:
												tile.active(true);
												tile.type = 2;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 11:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, 85, true, true, -1, 1);
												}
												break;
											case 12:
												tile.active(true);
												tile.type = 2;
												tile.slope(0);
												tile.halfBrick(true);
												break;
											case 13:
												tile.active(true);
												tile.type = 1;
												tile.slope(0);
												tile.halfBrick(true);
												break;
											case 14:
												tile.active(true);
												tile.type = 1;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 15:
												tile.active(true);
												tile.type = 0;
												tile.slope(0);
												tile.halfBrick(false);
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 11)
					{
						int[,] _structure = {
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0},
							{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1},
							{0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1},
							{0,0,0,0,2,0,0,2,2,2,0,0,0,2,2,2,1},
							{0,2,0,0,2,0,0,2,2,2,2,0,2,2,2,2,1},
							{2,2,0,0,2,2,0,2,2,2,2,2,2,2,2,2,1},
							{2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,1,1},
							{2,2,2,0,2,2,2,2,2,2,2,2,2,3,2,0,0},
							{2,2,0,0,2,2,0,2,2,2,2,2,2,1,1,1,0},
							{2,2,0,0,2,2,0,2,2,1,1,0,1,1,1,1,1},
							{2,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,1},
							{0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1},
							{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1},
							{0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1},
							{0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1}
						};
						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _structure.GetLength(1));
						PosY -= (int)(.5f * _structure.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
						{
							for (int i = 0; i < _structure.GetLength(0); i++)
							{
								for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_structure[i, j])
										{
											case 0:
												tile.active(true);
												tile.type = (ushort)mod.TileType("CursedHive");
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 1:
												tile.active(true);
												tile.type = (ushort)mod.TileType("PyramidSlabTile");
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 2:
												if (confirmPlatforms == 0)
												{
													tile.active(false);
													tile.halfBrick(false);
													tile.slope(0);
												}
												break;
											case 3:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile"), true, true, -1, 0);
												}
												break;
										}
									}
								}
							}
						}
					}
				}
				if (direction == 1)
				{
					//tile.type = 100;
					if (Main.rand.Next(2) != 0)
					{
						for (int checkRight = 0; checkRight < 300; checkRight++)
						{
							int check5 = 0;
							for (int h = 2; h >= -2; h--)
							{
								Tile checkTile = Framing.GetTileSafely(x + checkRight, y + h);
								if (CanTunnelTile(checkTile))
								{
									check5++;
								}
								if (StopTunnelTile(checkTile))
								{
									check5 = 5;
								}
								else
									checkTile.active(false);
							}
							if (check5 >= 5)
							{
								break;
							}
						}
					}
					if (variation == 0)
					{
						int[,] _pyramidRoom = {
							{3,1,1,1,1,1,1,1,1,2,3,3,3,3,3,3,3},
							{3,0,0,0,0,0,0,2,1,2,3,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,2,1,2,3,0,9,9,0,0,3},
							{3,0,0,0,0,0,0,2,1,2,3,0,6,9,0,0,3},
							{3,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2},
							{3,0,0,2,1,0,0,0,1,1,1,1,1,1,1,1,1},
							{3,0,0,2,1,0,0,0,0,0,0,0,3,0,0,0,0},
							{3,0,0,2,1,0,0,9,9,0,0,0,3,0,0,0,0},
							{3,0,0,2,1,4,0,9,9,0,0,0,3,0,0,0,0},
							{3,0,0,2,1,7,4,5,9,0,0,0,3,0,0,0,0},
							{3,0,0,2,1,2,2,2,2,2,0,0,3,0,0,0,0},
							{3,0,0,2,1,1,1,1,1,2,0,0,3,0,0,2,3},
							{2,0,0,2,2,2,2,2,1,2,0,0,3,0,0,2,3},
							{0,0,0,0,0,0,0,2,1,2,0,0,3,0,0,2,3},
							{0,4,4,4,4,0,0,2,1,2,0,0,0,0,0,2,3},
							{7,7,4,4,4,4,0,2,1,2,0,0,0,0,0,2,3},
							{7,7,7,7,7,7,7,2,1,2,0,0,0,0,0,2,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 331; //silver coin
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, Main.rand.Next(71)); //random statue
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(0);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 1)
					{
						int[,] _pyramidRoom = {
							{3,1,1,1,1,2,1,4,4,4,4,4,1,1,1,1,1},
							{3,3,4,4,4,2,1,1,1,1,1,4,4,1,1,1,1},
							{3,3,3,4,4,2,2,2,2,2,1,4,4,4,1,1,1},
							{3,3,3,3,4,4,4,4,0,0,1,0,4,0,0,1,1},
							{3,3,3,3,3,4,0,0,0,0,0,0,0,0,0,0,1},
							{3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0},
							{3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0},
							{3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0},
							{3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0},
							{3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0},
							{3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0},
							{3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0},
							{3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2},
							{3,0,0,0,3,3,3,3,3,3,3,3,2,1,1,1,1},
							{3,9,9,0,3,3,3,3,3,3,3,3,2,1,0,0,1},
							{3,6,9,0,3,3,3,3,3,3,3,3,2,1,0,0,1},
							{3,3,3,3,3,3,3,3,3,3,3,3,2,1,1,1,1}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, Main.rand.Next(71)); //random statue
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(0);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 2)
					{
						int[,] _pyramidRoom = {
							{2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,1,1},
							{1,1,1,1,1,2,2,2,2,4,4,4,1,1,2,2,1},
							{1,0,0,0,1,1,2,2,2,4,4,4,4,1,2,2,2},
							{0,7,7,7,0,1,1,1,1,4,4,4,4,1,1,1,2},
							{7,7,7,7,7,1,1,1,1,4,4,0,0,0,0,1,1},
							{7,7,7,7,7,1,1,1,1,4,0,0,0,0,0,0,0},
							{2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0},
							{2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0},
							{2,2,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{2,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{4,0,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,6,9,0,0,0,0,0,0,0,0,0,0,0,0,1},
							{0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,1,1},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
							{8,8,8,8,8,8,8,8,8,8,8,8,8,1,1,1,1},
							{8,8,8,8,8,8,8,8,8,8,8,8,1,1,1,1,2},
							{8,8,8,8,8,8,8,8,8,8,8,1,1,1,1,2,2}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, Main.rand.Next(71)); //random statue
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 3)
					{
						int[,] _pyramidRoom = {
							{1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{1,2,2,2,0,0,0,0,0,0,0,0,0,5,0,5,0},
							{1,1,1,1,1,0,0,0,0,0,0,2,1,1,1,1,1},
							{0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,1},
							{5,0,5,0,0,0,0,0,0,0,0,0,0,0,0,2,1},
							{1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,2,2},
							{1,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0},
							{1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3},
							{0,0,9,0,0,0,0,2,2,2,2,2,0,0,0,2,3},
							{2,2,2,2,2,2,8,8,8,2,8,8,8,8,8,2,3},
							{3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,2,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												GenerateCrate(k, l, mod); //crates
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 93; //tikitorch
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 102, true, true, -1); //throne
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 4)
					{
						int[,] _pyramidRoom = {
							{3,3,3,2,3,0,0,0,0,0,0,0,0,0,0,0,3},
							{0,0,3,2,3,0,0,0,0,0,0,0,0,0,0,0,3},
							{0,0,3,2,3,0,0,0,0,0,3,3,3,3,3,3,3},
							{0,0,3,2,3,0,0,0,0,0,3,2,2,2,2,2,2},
							{0,0,3,2,3,6,0,0,0,0,0,2,0,0,0,0,0},
							{0,0,0,2,3,3,3,3,0,0,0,0,0,4,8,4,0},
							{0,0,0,2,2,2,2,0,0,0,0,0,0,3,3,3,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,2,2,3,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,2,3,0,7,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,2,3,3,3,3,3,0,0,0,0,0,0,0,0},
							{0,0,0,2,3,2,2,2,0,0,0,0,0,0,0,0,0},
							{0,0,0,2,3,2,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,3,2,0,0,0,0,0,0,0,0,0,0,0},
							{8,8,8,8,3,2,8,8,8,8,8,8,8,8,8,8,8}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.halfBrick(true);
												tile.active(true);
												break;
											case 5:
												tile.active(true);
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, Main.rand.Next(71)); //random statue
												break;
											case 7:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("CrystalStatue")); //heart crystal
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(true);
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 5)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,2,3,3,3,3,3,2,3,3,3,3,3},
							{3,6,6,6,6,2,1,1,1,1,1,2,6,6,6,6,3},
							{3,0,6,0,6,6,6,6,6,6,6,6,6,0,6,0,3},
							{3,0,0,0,6,0,0,0,6,0,0,0,6,0,0,0,3},
							{3,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,3},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0},
							{3,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,3},
							{3,0,0,0,6,0,0,0,2,0,0,0,6,0,0,0,3},
							{3,0,6,0,6,6,6,6,2,6,6,6,6,0,6,0,3},
							{3,6,6,6,6,2,1,1,1,1,1,2,6,6,6,6,3},
							{3,3,3,3,3,2,3,3,3,3,3,2,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												GenerateCrate(k, l, mod); //crates
												break;
											case 6:
												tile.type = 232; //wooden spike
												tile.active(true);
												break;
											case 7:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 6)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,3,3,3,2,2,2,2,2,3,3,3,0,0,3},
							{3,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,3},
							{0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0},
							{0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,4,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0},
							{0,0,0,3,7,7,7,7,0,7,7,7,7,3,0,0,0},
							{3,0,0,3,7,7,7,7,7,7,7,7,7,3,0,0,3},
							{3,0,0,3,3,3,2,2,2,2,2,3,3,3,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 219); //extractinator
												break;
											case 5:
												tile.type = 232; //spike
												tile.active(true);
												break;
											case 6:
												tile.active(false);
												GenerateCrate(k, l, mod); //crates
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 7)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,3,3,3,2,3,3,3,3,3,7,3,3},
							{4,4,4,4,2,2,2,2,2,2,2,2,2,7,7,7,2},
							{4,4,4,0,0,3,3,3,2,3,3,3,7,3,3,3,3},
							{4,4,0,0,0,0,2,2,2,2,2,7,7,7,2,2,2},
							{4,0,0,0,0,0,0,3,2,3,7,3,3,3,3,3,3},
							{4,0,0,0,0,0,0,0,2,7,7,7,2,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{2,2,2,2,2,7,7,7,2,0,0,0,0,0,0,0,0},
							{3,3,3,3,3,3,7,3,2,3,0,0,0,0,0,0,0},
							{2,2,2,7,7,7,2,2,2,2,2,8,8,8,8,8,8},
							{3,3,3,3,7,3,3,3,2,3,3,3,8,8,8,8,8},
							{2,7,7,7,2,2,2,2,2,2,2,2,2,8,8,8,8},
							{3,3,7,3,3,3,3,3,2,3,3,3,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, Main.rand.Next(71)); //random statue
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 232; //spike
												tile.active(true);
												break;
											case 8:
												tile.liquidType(0);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 240, true, true, -1, Main.rand.Next(16, 18)); //hanging skeleton
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 8)
					{
						int[,] _pyramidRoom = {
							{4,4,4,4,4,0,0,0,4,4,7,7,7,7,7,7,7},
							{4,4,0,0,0,0,0,0,0,4,7,3,3,3,3,3,3},
							{4,0,0,9,0,0,0,0,0,0,0,0,7,7,7,7,7},
							{0,0,0,0,0,0,0,0,0,0,0,0,7,3,3,3,3},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,7},
							{6,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0},
							{1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{3,3,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0},
							{7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0},
							{3,3,3,3,3,3,7,0,0,0,0,0,0,0,0,0,0},
							{7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0},
							{3,3,3,3,3,3,3,3,7,0,0,0,0,0,0,0,0},
							{7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,4},
							{3,3,3,3,3,3,3,3,3,3,7,2,2,7,0,4,4},
							{7,7,7,7,7,7,7,7,7,7,7,2,2,7,7,7,7},
							{3,3,3,3,3,3,3,3,3,3,3,2,2,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												GenerateCrate(k, l, mod); //crates
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 232; //wooden spike
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 240, true, true, -1, Main.rand.Next(16, 18)); //hanging skeleton
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 9)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3},
							{3,1,1,2,2,2,2,2,3,3,1,1,1,1,1,1,3},
							{3,1,2,2,2,2,2,3,3,1,1,0,0,0,9,9,3},
							{3,3,3,3,3,3,3,3,1,1,0,0,0,0,0,0,3},
							{3,1,1,1,1,1,1,1,1,0,0,0,4,4,7,0,3},
							{3,9,9,0,0,0,0,0,0,0,0,0,4,1,1,1,3},
							{3,9,0,0,0,5,0,0,0,0,0,4,1,1,0,0,0},
							{3,0,0,0,0,0,0,0,4,4,4,1,1,0,0,0,0},
							{3,0,0,0,4,4,4,4,4,4,1,1,0,0,0,0,0},
							{3,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0},
							{3,0,0,0,0,0,0,0,9,9,0,0,0,0,0,0,0},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,3},
							{3,9,0,0,0,0,0,0,0,0,0,0,0,1,1,2,3},
							{3,9,9,0,0,0,0,0,0,0,0,0,1,1,2,2,3},
							{3,9,9,0,0,0,0,0,0,0,0,1,1,2,2,2,3},
							{3,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,3},
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 332; //coins
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 240, true, true, -1, Main.rand.Next(16, 18)); //hanging skeleton
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("CrystalStatue")); //heart crystal
												break;
											case 7:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 10)
					{
						int[,] _structure = {
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,1,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0},
							{3,4,0,0,0,5,6,6,0,0,0,0,0,0,0,0,0},
							{7,7,0,0,5,6,8,0,0,0,0,0,0,0,0,0,0},
							{7,7,0,5,6,8,5,6,6,9,0,0,0,0,0,0,0},
							{7,7,5,6,8,5,6,6,6,6,9,0,0,4,0,0,0},
							{7,6,6,8,5,6,6,0,0,6,6,9,0,4,0,0,0},
							{6,6,6,2,2,2,2,10,0,6,6,6,6,7,7,0,0},
							{6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,4,0},
							{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7},
							{6,6,6,0,0,6,6,6,6,6,6,6,6,6,6,6,7},
							{6,6,6,11,0,6,6,6,6,6,6,6,6,6,6,6,6},
							{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6},
							{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6},
							{6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6}
						};
						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _structure.GetLength(1));
						PosY -= (int)(.5f * _structure.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
						{
							for (int i = 0; i < _structure.GetLength(0); i++)
							{
								for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_structure[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
												{
													tile.active(false);
													tile.halfBrick(false);
													tile.slope(0);
												}
												break;
											case 1:
												tile.active(true);
												tile.type = 188;
												tile.slope(0);
												tile.halfBrick(true);
												break;
											case 2:
												tile.active(true);
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>();
												tile.slope(0);
												tile.halfBrick(true);
												break;
											case 3:
												tile.active(true);
												tile.type = 53;
												tile.slope(1);
												tile.halfBrick(false);
												break;
											case 4:
												tile.active(true);
												tile.type = 188;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 5:
												tile.active(true);
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>();
												tile.slope(2);
												tile.halfBrick(false);
												break;
											case 6:
												tile.active(true);
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>();
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 7:
												tile.active(true);
												tile.type = 53;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 8:
												tile.active(true);
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>();
												tile.slope(3);
												tile.halfBrick(false);
												break;
											case 9:
												tile.active(true);
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>();
												tile.slope(1);
												tile.halfBrick(false);
												break;
											case 10:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile"), true, true, -1, 0);
												}
												break;
											case 11:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, (ushort)mod.TileType("CrystalStatue"), true, true, -1, 0);
												}
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 11)
					{
						int[,] _structure = {
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0},
							{1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0},
							{1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0},
							{1,2,2,1,1,2,1,1,2,2,2,2,2,1,1,1,0},
							{1,1,2,2,1,2,1,2,2,1,1,1,1,1,1,0,0},
							{0,1,1,2,2,2,2,2,1,1,0,0,0,0,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,2,2,2,3,0,2,2,0,0,0,0,4,0,0,5,5},
							{5,5,2,2,2,2,2,2,2,5,5,5,5,5,5,5,6},
							{6,6,6,2,6,6,6,2,2,2,2,6,7,7,7,7,6},
							{6,6,2,2,6,6,6,2,2,6,7,7,8,0,0,10,7},
							{6,6,2,6,6,6,6,6,2,7,7,11,0,9,0,11,7},
							{6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,6}
						};
						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _structure.GetLength(1));
						PosY -= (int)(.5f * _structure.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
						{
							for (int i = 0; i < _structure.GetLength(0); i++)
							{
								for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_structure[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
												{
													tile.active(false);
													tile.halfBrick(false);
													tile.slope(0);
												}
												break;
											case 1:
												tile.active(true);
												tile.type = 192;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 2:
												tile.active(true);
												tile.type = 191;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 3:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile"), true, true, -1, 0);
												}
												break;
											case 4:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, 86, true, true, -1, 0);
												}
												break;
											case 5:
												tile.active(true);
												tile.type = 2;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 6:
												tile.active(true);
												tile.type = 0;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 7:
												tile.active(true);
												tile.type = 1;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 8:
												tile.active(true);
												tile.type = 1;
												tile.slope(3);
												tile.halfBrick(false);
												break;
											case 9:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, (ushort)mod.TileType("CrystalStatue"), true, true, -1, 0);
												}
												break;
											case 10:
												tile.active(true);
												tile.type = 1;
												tile.slope(4);
												tile.halfBrick(false);
												break;
											case 11:
												tile.active(true);
												tile.type = 1;
												tile.slope(0);
												tile.halfBrick(true);
												break;
										}
									}
								}
							}
						}
					}

				}
				if (direction == 2)
				{
					//tile.type = 150;
					if (Main.rand.Next(2) != 0)
					{
						for (int checkUp = 0; checkUp < 300; checkUp++)
						{
							int check5 = 0;
							for (int h = 2; h >= -2; h--)
							{
								Tile checkTile = Framing.GetTileSafely(x + h, y - checkUp);
								if (CanTunnelTile(checkTile))
								{
									check5++;
								}
								if (StopTunnelTile(checkTile))
								{
									check5 = 5;
								}
								else
									checkTile.active(false);
							}
							if (check5 >= 5)
							{
								break;
							}
						}
					}
					if (variation == 0)
					{
						int[,] _pyramidRoom = {
							{3,3,3,4,4,4,0,0,0,0,0,0,2,3,3,3,3},
							{2,2,2,2,4,0,0,0,0,0,0,0,2,4,4,4,3},
							{3,4,4,4,0,0,0,0,0,0,0,0,2,4,4,4,3},
							{3,4,4,4,0,0,2,2,2,2,2,2,2,0,4,4,3},
							{3,4,4,0,0,0,0,0,4,4,4,4,0,0,0,4,3},
							{3,4,4,0,0,0,0,0,0,0,0,0,0,0,0,4,3},
							{3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2},
							{2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,3},
							{4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3},
							{4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,2,3},
							{3,3,3,3,3,2,0,0,0,0,0,0,0,0,0,2,3},
							{3,0,0,7,0,2,0,0,0,0,0,0,0,0,2,2,3},
							{3,7,7,7,0,2,0,0,0,0,0,0,0,0,0,0,3},
							{3,7,7,7,7,2,0,0,0,0,0,0,0,0,0,0,3},
							{3,7,7,7,7,2,0,0,0,0,0,0,0,9,9,0,3},
							{3,7,7,7,7,2,2,2,2,2,2,2,0,6,9,0,3},
							{3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, Main.rand.Next(71)); //random statue
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(0);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 1)
					{
						int[,] _pyramidRoom = {
							{2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,1,1},
							{2,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1},
							{2,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},
							{2,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},
							{2,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},
							{2,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0},
							{2,0,0,0,0,2,2,2,2,2,2,2,1,1,1,1,2},
							{2,0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,2},
							{2,0,0,0,0,0,4,4,7,7,2,2,0,0,0,0,2},
							{2,0,0,0,0,0,0,0,4,7,2,2,0,0,0,0,2},
							{2,0,0,0,0,0,0,0,4,7,2,2,0,0,0,0,2},
							{2,0,0,0,0,0,0,0,0,7,2,2,0,0,0,4,2},
							{2,4,0,0,0,6,0,0,0,7,2,2,0,0,0,4,2},
							{2,4,4,0,0,9,9,0,0,7,2,2,0,0,4,7,2},
							{2,7,4,0,0,0,0,0,0,7,2,2,7,4,4,7,2},
							{2,7,7,7,7,7,7,7,7,7,2,2,7,7,7,7,2},
							{2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, Main.rand.Next(71)); //random statue
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 232; //wooden spike
												tile.active(true);
												break;
											case 8:
												tile.liquidType(0);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 2)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,2,4,0,0,0,0,0,4,2,3,3,3,3},
							{3,4,2,3,2,4,0,0,0,0,0,4,2,3,2,4,3},
							{4,4,2,3,2,4,0,0,0,0,0,4,2,3,2,4,4},
							{4,0,2,3,4,0,0,0,0,0,0,0,4,3,2,0,4},
							{4,0,2,3,4,0,0,0,0,0,0,0,4,3,2,0,4},
							{0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0},
							{0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,9,0,0,0,0,0,0,0,0,0,0,0,0,9,0,0},
							{3,3,3,2,0,0,0,0,0,0,0,0,0,2,3,3,3},
							{3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3},
							{2,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,2},
							{7,0,0,7,0,0,7,3,7,3,7,0,0,7,0,0,7},
							{7,0,7,7,7,0,7,3,2,3,7,0,7,7,7,0,7},
							{7,7,2,7,2,7,7,3,2,3,7,7,2,7,2,7,7}
						};

						int PosX = x - (int)(.5f * _pyramidRoom.GetLength(1));
						int PosY = y - (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, Main.rand.Next(71)); //random statue
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 232; //wooden spike
												tile.active(true);
												break;
											case 8:
												tile.liquidType(0);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("CrystalStatue")); //heart crystal
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 3)
					{
						int[,] _pyramidRoom = {
							{1,1,1,1,1,2,0,0,0,0,0,2,1,1,1,1,1},
							{1,1,1,4,4,2,0,0,0,0,0,2,0,4,1,1,1},
							{1,4,4,0,4,2,1,1,1,1,1,2,0,4,4,4,1},
							{1,4,0,0,4,4,4,0,0,0,0,0,4,4,4,4,1},
							{4,4,0,0,0,4,0,0,0,0,0,4,4,4,4,4,4},
							{4,0,0,0,0,4,0,0,0,0,0,4,4,4,4,4,4},
							{4,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4},
							{0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4},
							{4,0,2,0,0,0,0,0,0,0,0,0,0,4,2,4,4},
							{4,4,2,0,0,0,0,0,0,0,0,0,0,0,2,4,4},
							{4,4,2,0,0,0,0,0,0,0,0,0,0,0,2,4,4},
							{0,4,2,0,0,0,0,0,0,0,0,0,0,0,2,4,0},
							{0,0,2,8,8,8,8,8,8,8,8,8,8,8,2,0,7},
							{7,0,2,8,8,8,8,8,8,8,8,8,8,8,2,7,7},
							{7,7,2,8,8,8,2,8,8,8,2,8,8,8,2,7,7},
							{1,1,2,2,2,2,2,8,8,8,2,2,2,2,2,1,1}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 377); //sharpening station
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 4)
					{
						int[,] _pyramidRoom = {
							{4,4,4,4,0,0,0,0,0,0,0,0,0,4,4,4,4},
							{2,2,2,2,2,0,0,0,0,0,0,0,2,2,2,2,2},
							{4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4},
							{2,2,2,2,0,0,0,0,0,0,0,0,0,2,2,2,2},
							{4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4},
							{2,2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,2},
							{8,5,0,0,0,0,0,0,0,0,0,0,0,0,0,5,8},
							{2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{2,2,0,0,0,0,0,0,6,0,0,0,0,0,0,2,2},
							{0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,0},
							{2,2,2,0,0,0,2,3,2,3,2,0,0,0,2,2,2},
							{0,0,0,0,0,0,0,3,2,3,0,0,0,0,0,0,0},
							{2,2,2,2,0,0,0,3,2,3,0,0,0,2,2,2,2},
							{8,8,8,8,8,8,3,3,2,3,3,8,8,8,8,8,8}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.halfBrick(true);
												tile.active(true);
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 77); //hellforge
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 5)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,0,0,0,0,0,0,0,0,0,3,3,3,3},
							{2,2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,2},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2},
							{5,5,5,0,0,0,0,0,0,0,0,0,0,0,5,5,5},
							{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
							{5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5},
							{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
							{5,6,0,0,0,0,0,0,0,0,0,0,0,0,6,0,5},
							{2,9,9,9,0,0,0,0,0,0,0,0,0,9,9,9,2},
							{5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5},
							{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
							{5,5,5,0,0,0,0,0,0,0,0,0,0,0,5,5,5},
							{2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{2,2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,2},
							{3,3,3,3,0,0,0,0,0,0,0,0,0,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.type = 232; //spike
												tile.active(true);
												break;
											case 6:
												tile.active(false);
												GenerateCrate(k, l, mod); //crates
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 6)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,3,3,3,2,2,2,2,2,3,3,3,0,0,3},
							{3,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,3},
							{0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0},
							{0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,4,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0},
							{0,0,0,3,7,7,7,7,0,7,7,7,7,3,0,0,0},
							{3,0,0,3,7,7,7,7,7,7,7,7,7,3,0,0,3},
							{3,0,0,3,3,3,2,2,2,2,2,3,3,3,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 219); //extractinator
												break;
											case 5:
												tile.type = 232; //spike
												tile.active(true);
												break;
											case 6:
												tile.active(false);
												GenerateCrate(k, l, mod); //crates
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 7)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,3,0,0,0,0,0,3,3,3,3,3,3},
							{3,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,3},
							{3,0,0,0,0,0,0,0,0,0,0,2,3,3,3,2,3},
							{3,0,0,0,0,0,0,0,0,0,0,2,3,2,3,2,3},
							{3,0,0,0,0,0,0,0,4,0,0,2,3,2,3,2,3},
							{3,0,0,0,0,0,0,0,0,0,0,2,3,2,3,2,3},
							{3,6,0,0,5,0,0,0,0,0,0,2,3,2,3,2,3},
							{3,2,1,3,3,3,3,3,3,3,2,2,3,2,3,2,3},
							{3,2,1,3,2,2,2,3,2,3,2,3,3,2,3,2,3},
							{3,2,1,3,3,3,2,3,2,3,2,3,2,2,3,2,3},
							{3,2,1,1,1,3,2,3,2,3,2,3,2,3,3,2,3},
							{3,2,3,3,1,3,2,3,2,3,2,3,2,3,3,2,3},
							{3,2,2,2,1,3,2,3,2,3,2,3,2,3,3,2,3},
							{3,3,3,2,1,3,2,3,2,3,2,3,2,3,3,2,3},
							{3,3,3,2,1,3,3,3,2,3,2,3,2,3,3,2,3},
							{3,3,3,2,1,0,0,3,2,3,2,3,2,3,3,2,3},
							{3,3,3,2,1,7,0,3,2,3,2,3,2,2,2,2,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												if (confirmPlatforms == 1)
													WorldGen.PlaceTile(k, l, 240, true, true, -1, Main.rand.Next(16, 18)); //hanging skeleton
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 215); //campfire
												break;
											case 6:
												tile.active(false);
												GenerateCrate(k, l, mod); //crates
												break;
											case 7:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 8)
					{
						int[,] _pyramidRoom = {
							{7,7,7,7,7,2,0,0,0,0,0,2,7,7,7,7,7},
							{7,0,0,0,7,2,0,0,0,0,9,2,7,0,0,0,7},
							{0,0,0,0,7,2,0,0,0,0,0,2,7,0,0,0,0},
							{0,0,0,0,7,2,0,0,0,0,0,2,0,0,5,0,0},
							{0,0,0,0,7,2,9,0,0,0,0,2,0,0,0,0,0},
							{0,0,5,0,0,2,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7},
							{0,0,2,0,0,0,0,0,0,0,0,0,0,0,3,3,3},
							{0,0,2,0,0,0,0,0,7,0,0,0,0,0,0,0,3},
							{0,0,2,0,0,0,0,0,7,0,0,0,0,0,0,0,7},
							{0,0,2,0,0,0,0,0,7,0,0,0,0,0,0,0,7},
							{6,0,2,0,0,0,0,0,7,7,0,0,0,0,0,0,7},
							{9,9,2,0,0,0,0,7,3,7,0,0,0,0,0,7,7},
							{7,7,2,7,7,7,7,3,3,3,3,7,7,7,7,7,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 240, true, true, -1, Main.rand.Next(16, 18)); //hanging skeleton
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 232; //wooden spike
												tile.active(true);
												break;
											case 8:
												tile.liquidType(0);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 9)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,2,0,0,0,0,0,2,3,3,3,3,3},
							{3,7,7,7,3,2,0,0,0,0,0,2,3,2,2,2,2},
							{3,7,0,7,3,2,0,0,0,0,0,2,3,2,0,0,0},
							{3,7,0,7,3,2,0,0,0,0,0,2,3,2,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,2,3,2,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,2,3,2,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,2,3,2,0,0,0},
							{0,0,2,2,2,2,2,2,2,2,2,2,3,2,0,0,0},
							{0,0,0,2,3,2,3,3,3,3,3,2,3,2,0,0,0},
							{0,0,0,2,3,2,3,7,7,7,3,2,3,0,0,0,0},
							{0,0,0,0,3,2,3,7,0,7,3,2,3,0,0,6,0},
							{3,0,0,0,0,2,3,7,0,7,3,2,0,0,0,9,3},
							{3,0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,3},
							{2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,7,2},
							{3,3,7,0,0,0,0,0,0,0,0,0,0,0,7,3,3},
							{3,0,3,7,0,0,0,0,0,0,0,0,0,7,3,2,3},
							{3,3,3,2,3,2,0,0,0,0,0,2,3,2,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 240, true, true, -1, Main.rand.Next(16, 18)); //hanging skeleton
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 232; //wooden spike
												tile.active(true);
												break;
											case 8:
												tile.liquidType(0);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 10)
					{
						int[,] _structure = {
							{0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0},
							{0,2,2,2,0,0,1,1,1,1,1,0,0,2,2,2,0},
							{0,2,2,2,0,1,1,1,1,1,1,1,0,2,2,2,0},
							{0,0,0,2,0,1,1,1,1,1,1,1,0,2,2,2,0},
							{0,3,0,2,0,1,1,1,1,1,1,1,0,2,0,0,0},
							{0,3,0,0,0,1,1,1,1,1,1,1,0,0,0,3,0},
							{0,3,0,0,1,1,1,1,1,1,1,1,1,0,0,3,0},
							{0,3,0,0,1,1,1,1,1,1,1,1,1,0,0,3,0},
							{0,3,4,1,1,1,1,1,1,1,1,1,1,1,1,3,0},
							{0,1,4,1,1,1,1,1,1,1,1,1,1,1,1,3,0},
							{0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
							{0,1,5,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
							{0,1,7,7,1,1,1,1,1,1,1,1,1,1,1,1,0},
							{0,1,1,1,1,1,1,1,6,1,1,1,1,1,1,1,0},
							{0,0,1,3,1,1,0,0,0,0,0,1,1,3,1,0,0},
							{0,0,3,3,3,0,0,2,2,2,0,0,3,3,3,0,0},
							{0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0}
						};
						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _structure.GetLength(1));
						PosY -= (int)(.5f * _structure.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
						{
							for (int i = 0; i < _structure.GetLength(0); i++)
							{
								for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_structure[i, j])
										{
											case 0:
												tile.active(true);
												tile.type = 2;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 1:
												if (confirmPlatforms == 0)
												{
													tile.active(false);
													tile.halfBrick(false);
													tile.slope(0);
												}
												break;
											case 2:
												tile.active(true);
												tile.type = 0;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 3:
												tile.active(true);
												tile.type = 232;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 4:
												tile.active(true);
												tile.type = 52;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 5:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile"), true, true, -1, 0);
												}
												break;
											case 6:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, 304, true, true, -1, 0);
												}
												break;
											case 7:
												if (confirmPlatforms == 0)
													tile.active(false);
												WorldGen.PlaceTile(k, l, 19, true, true, -1, 0);
												tile.slope(0);
												tile.halfBrick(false);
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 11)
					{
						int[,] _structure = {
							{0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1},
							{0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1},
							{0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
							{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
							{0,0,2,1,1,1,1,1,1,1,1,1,1,1,2,1,0},
							{0,2,2,1,1,1,1,1,1,1,1,1,1,1,2,1,0},
							{0,2,2,1,1,1,1,1,1,1,3,1,1,1,2,1,0},
							{0,2,2,1,1,1,1,1,1,4,4,4,4,1,2,2,0},
							{0,0,2,2,1,1,2,1,1,1,1,1,1,2,2,2,0},
							{0,0,0,2,1,1,2,1,1,1,1,1,0,2,2,2,0},
							{0,0,0,2,1,1,2,1,1,2,1,1,0,2,2,0,0},
							{0,0,0,0,2,1,2,1,2,2,1,0,0,0,2,0,0},
							{0,0,0,0,2,2,2,2,2,2,0,0,0,0,2,0,0},
							{0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
						};
						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _structure.GetLength(1));
						PosY -= (int)(.5f * _structure.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
						{
							for (int i = 0; i < _structure.GetLength(0); i++)
							{
								for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_structure[i, j])
										{
											case 0:
												tile.active(true);
												tile.type = (ushort)mod.TileType("CursedHive");
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 1:
												if (confirmPlatforms == 0)
												{
													tile.active(false);
													tile.halfBrick(false);
													tile.slope(0);
												}
												break;
											case 2:
												tile.active(true);
												tile.type = 232;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 3:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile"), true, true, -1, 0);
												}
												break;
											case 4:
												if (confirmPlatforms == 0)
													tile.active(false);
												WorldGen.PlaceTile(k, l, 19, true, true, -1, 0);
												tile.slope(0);
												tile.halfBrick(false);
												break;
										}
									}
								}
							}
						}
					}

				}
				if (direction == 3)
				{
					//tile.type = 50;
					if (Main.rand.Next(2) != 0)
					{
						for (int checkDown = 0; checkDown < 300; checkDown++)
						{
							int check5 = 0;
							for (int h = 2; h >= -2; h--)
							{
								Tile checkTile = Framing.GetTileSafely(x + h, y + checkDown);
								if (CanTunnelTile(checkTile))
								{
									check5++;
								}
								if (StopTunnelTile(checkTile))
								{
									check5 = 5;
								}
								else
									checkTile.active(false);
							}
							if (check5 >= 5)
							{
								break;
							}
						}
					}
					if (variation == 0)
					{
						int[,] _pyramidRoom = {
							{7,7,7,7,7,4,4,4,4,2,3,3,3,3,3,3,3},
							{3,3,3,3,7,4,4,4,4,2,3,2,2,2,2,2,3},
							{2,2,2,3,7,4,4,4,0,2,3,3,3,3,3,2,3},
							{4,2,3,3,2,7,4,4,0,2,2,2,2,2,2,2,3},
							{4,2,2,2,2,3,7,0,0,0,0,0,3,3,3,3,3},
							{4,4,3,3,3,3,7,0,0,0,9,9,3,4,4,4,4},
							{4,4,4,7,3,7,0,0,0,0,6,9,3,0,4,4,4},
							{4,4,7,2,3,7,0,0,3,3,3,3,3,0,7,7,7},
							{4,4,7,2,3,2,0,0,0,0,0,0,0,0,7,2,2},
							{4,7,3,3,3,3,3,0,0,0,0,0,0,0,7,2,3},
							{4,0,7,2,3,2,0,0,0,0,0,7,7,7,7,2,3},
							{0,0,7,2,3,0,0,0,0,0,0,7,2,2,2,2,3},
							{0,0,0,7,3,0,0,0,0,0,0,7,2,3,3,3,3},
							{7,0,0,0,0,0,0,0,0,0,0,7,2,3,3,3,3},
							{3,7,0,0,9,9,0,0,0,0,0,7,2,3,3,3,3},
							{3,2,7,0,9,9,0,0,0,0,0,7,2,3,3,3,3},
							{3,2,3,7,5,9,0,0,0,0,0,7,2,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, Main.rand.Next(71)); //random statue
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 232; //wooden spike
												tile.active(true);
												break;
											case 8:
												tile.liquidType(0);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 1)
					{
						int[,] _pyramidRoom = {
							{2,1,1,2,2,1,1,1,1,1,1,1,2,2,1,1,2},
							{1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1},
							{1,2,2,2,0,0,0,0,0,0,4,4,4,2,2,2,1},
							{2,2,2,0,0,0,0,0,0,0,0,4,4,4,2,2,2},
							{2,2,0,0,0,0,0,0,0,0,0,0,0,4,4,2,2},
							{3,4,0,0,0,0,0,0,0,0,0,0,0,0,4,4,3},
							{3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{4,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0},
							{4,0,0,0,0,1,1,1,1,2,1,1,1,0,0,0,0},
							{0,0,0,0,0,0,0,7,1,1,1,1,1,1,0,0,8},
							{0,0,0,0,0,6,0,7,1,1,1,1,1,1,1,8,8},
							{9,9,9,9,9,1,1,1,1,1,1,1,1,1,1,1,8},
							{1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1},
							{1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1},
							{1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1},
							{1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1},
							{1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Statues, true, true, -1, Main.rand.Next(71)); //random statue
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 232; //wooden spike
												tile.active(true);
												break;
											case 8:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 2)
					{
						int[,] _pyramidRoom = {
							{3,4,4,4,4,4,4,0,3,3,3,3,3,3,3,3,3},
							{3,4,4,4,4,0,0,0,0,2,2,3,2,2,2,2,2},
							{3,4,0,0,0,0,0,0,0,0,2,3,2,4,4,4,4},
							{3,0,0,0,0,0,0,0,0,0,2,3,2,0,4,4,4},
							{3,0,0,0,0,0,0,0,0,0,2,3,2,0,0,0,4},
							{3,0,0,0,0,0,0,0,0,0,0,3,2,0,0,0,0},
							{3,0,5,0,0,0,0,0,0,0,0,3,2,0,0,0,0},
							{3,3,3,3,3,3,9,9,9,9,9,3,0,0,0,0,0},
							{3,2,2,2,2,0,0,0,0,0,0,3,0,0,0,0,0},
							{3,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{3,7,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0},
							{3,7,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3},
							{2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,2,3},
							{3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,2,3},
							{2,2,2,2,0,0,0,0,0,0,0,2,2,2,2,2,2},
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 377); //sharpening station
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 232; //wooden spike
												tile.active(true);
												break;
											case 8:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("CrystalStatue")); //heart crystal
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 3)
					{
						int[,] _pyramidRoom = {
							{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
							{1,4,4,0,0,0,0,0,0,0,0,0,0,4,4,4,4},
							{1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4},
							{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4},
							{1,0,0,0,2,2,2,2,2,2,2,2,0,0,2,0,0},
							{1,0,0,0,0,0,0,0,4,4,2,2,0,0,2,0,0},
							{1,0,0,0,0,0,0,0,0,4,2,2,0,0,2,0,0},
							{1,0,0,0,0,0,0,0,0,0,2,2,0,0,2,0,0},
							{2,2,2,2,2,2,2,0,0,0,2,2,0,0,2,0,0},
							{1,4,4,0,0,0,0,0,0,0,2,2,4,4,2,6,0},
							{1,4,0,0,0,0,0,0,0,0,2,2,0,0,2,9,9},
							{1,0,0,0,0,0,0,0,0,0,2,2,0,0,2,0,0},
							{1,0,0,0,2,2,2,2,2,2,2,2,0,0,2,0,0},
							{1,0,0,0,0,0,0,0,0,0,0,2,8,8,2,0,0},
							{1,0,0,0,0,0,0,0,0,0,0,2,8,8,2,0,0},
							{1,0,0,0,0,0,0,0,0,0,0,2,8,8,2,0,0},
							{1,1,1,1,1,1,0,0,0,0,0,2,2,2,2,2,2}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 377); //sharpening station
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 4)
					{
						int[,] _pyramidRoom = {
							{0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1},
							{0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,1},
							{0,6,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1},
							{3,3,3,3,3,0,0,0,0,0,0,1,0,1,1,1,1},
							{3,2,2,2,2,2,0,0,0,0,1,0,0,0,1,1,1},
							{3,3,2,1,1,1,1,0,0,0,0,1,0,1,0,0,0},
							{2,2,2,1,0,0,0,0,0,0,1,0,1,0,0,1,0},
							{0,1,2,1,0,0,0,0,0,0,0,0,0,0,0,1,0},
							{0,1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,1,2,1,0,0,0,0,0,0,0,0,0,0,3,3,3},
							{0,1,1,1,0,0,0,0,0,0,0,0,0,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3},
							{0,0,0,0,0,0,0,0,0,0,0,0,3,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,3,2,0,0,0},
							{0,0,9,0,0,0,0,0,0,0,0,0,3,2,0,0,0},
							{2,2,2,2,2,0,0,0,0,0,0,0,3,2,0,0,0},
							{3,3,3,3,0,0,0,0,0,0,0,0,3,2,0,6,0}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 377); //sharpening station
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 354); //bewitching table
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 5)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,0,0,0,0,0,0,0,0,0,3,3,3,3},
							{2,2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,2},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2},
							{5,5,5,0,0,0,0,0,0,0,0,0,0,0,5,5,5},
							{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
							{5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5},
							{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
							{5,6,0,0,0,0,0,0,0,0,0,0,0,0,6,0,5},
							{2,9,9,9,0,0,0,0,0,0,0,0,0,9,9,9,2},
							{5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5},
							{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
							{5,5,5,0,0,0,0,0,0,0,0,0,0,0,5,5,5},
							{2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{2,2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,2},
							{3,3,3,3,0,0,0,0,0,0,0,0,0,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.type = 232; //spike
												tile.active(true);
												break;
											case 6:
												tile.active(false);
												GenerateCrate(k, l, mod); //crates
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 6)
					{
						int[,] _pyramidRoom = {
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,3,3,3,2,2,2,2,2,3,3,3,0,0,3},
							{3,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,3},
							{0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0},
							{0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,0,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,2,0,4,0,2,0,0,2,0,0,0},
							{0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0},
							{0,0,0,3,7,7,7,7,0,7,7,7,7,3,0,0,0},
							{3,0,0,3,7,7,7,7,7,7,7,7,7,3,0,0,3},
							{3,0,0,3,3,3,2,2,2,2,2,3,3,3,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3},
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 219); //extractinator
												break;
											case 5:
												tile.type = 232; //spike
												tile.active(true);
												break;
											case 6:
												tile.active(false);
												GenerateCrate(k, l, mod); //crates
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 7)
					{
						int[,] _pyramidRoom = {
							{4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0},
							{2,2,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0},
							{4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,6,0},
							{2,2,2,0,0,0,0,0,0,0,0,0,4,4,2,2,2},
							{4,4,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4},
							{2,2,2,2,0,0,0,0,0,0,0,0,0,0,4,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4},
							{2,2,2,2,2,0,0,0,0,0,0,0,0,0,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4},
							{2,2,2,2,2,2,0,0,0,0,0,0,0,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4},
							{2,2,2,2,2,2,2,0,0,0,0,0,2,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2},
							{0,5,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, 355); //alchemy table
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 8)
					{
						int[,] _pyramidRoom = {
							{4,3,3,3,0,0,0,0,3,0,0,0,0,3,3,3,4},
							{4,4,3,3,5,0,5,0,3,5,0,5,0,3,3,4,4},
							{4,4,4,3,3,3,3,3,3,3,3,3,3,3,4,4,4},
							{4,4,4,4,3,3,3,3,3,3,3,3,3,4,4,4,4},
							{4,4,4,0,0,3,3,3,3,3,3,3,0,0,4,4,4},
							{4,4,4,1,0,0,3,3,3,3,3,0,0,1,4,4,4},
							{4,4,0,1,1,0,0,3,3,3,0,0,1,1,0,4,4},
							{4,0,0,0,1,1,0,0,3,0,0,1,1,0,0,0,4},
							{4,0,1,0,0,1,1,0,0,0,1,1,0,0,1,0,4},
							{0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0},
							{0,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0},
							{0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4},
							{3,3,3,0,0,0,0,0,0,0,0,0,0,0,3,3,3},
							{2,2,2,2,0,0,0,0,0,0,0,0,0,2,2,2,2},
							{3,3,3,3,3,0,0,0,0,0,0,0,3,3,3,3,3},
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												GenerateCrate(k, l, mod); //crates
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 9)
					{
						int[,] _pyramidRoom = {
							{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
							{1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1},
							{1,2,2,3,2,1,1,1,2,2,2,2,2,2,2,2,1},
							{1,2,3,3,2,0,0,0,0,0,0,0,0,4,4,2,1},
							{1,2,2,3,2,0,0,0,0,0,0,0,0,0,4,2,1},
							{1,2,2,2,2,5,0,0,0,0,0,0,0,0,0,2,1},
							{1,2,3,2,2,1,1,1,1,1,1,1,1,0,0,2,1},
							{1,2,3,3,2,2,2,2,2,2,2,2,0,0,0,2,1},
							{1,2,3,2,2,1,1,1,1,2,2,0,0,0,0,2,1},
							{1,2,2,2,2,2,2,2,2,2,0,0,0,0,0,2,1},
							{1,2,2,4,4,4,0,0,0,0,0,0,0,0,2,2,1},
							{1,2,2,4,0,0,0,0,0,0,0,0,0,0,2,2,1},
							{1,2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,1},
							{1,2,2,1,6,0,0,0,0,0,0,6,0,1,2,2,1},
							{1,2,2,1,1,1,0,0,0,0,0,1,1,1,2,2,1},
							{1,2,2,2,2,2,0,0,0,0,0,2,2,2,2,2,1},
							{1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1}
						};

						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _pyramidRoom.GetLength(1));
						PosY -= (int)(.5f * _pyramidRoom.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)
						{
							for (int i = 0; i < _pyramidRoom.GetLength(0); i++)
							{
								for (int j = 0; j < _pyramidRoom.GetLength(1); j++)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_pyramidRoom[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
													tile.active(false);
												break;
											case 1:
												tile.type = 274; //sandstoneslab
												tile.active(true);
												break;
											case 2:
												tile.type = (ushort)mod.TileType("PyramidSlabTile"); //pyramid slab
												tile.active(true);
												break;
											case 3:
												tile.type = (ushort)ModContent.TileType<PyramidBrickTile>(); //sandstone brick
												tile.active(true);
												break;
											case 4:
												tile.type = 51; //cobweb
												tile.active(true);
												break;
											case 5:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile")); //chest
												break;
											case 6:
												tile.active(false);
												WorldGen.PlaceTile(k, l, (ushort)mod.TileType("CrystalStatue")); //chest
												break;
											case 7:
												tile.type = 332; //gold coin
												tile.active(true);
												break;
											case 8:
												tile.liquidType(1);
												tile.liquid = 255;

												if (confirmPlatforms == 0)
													tile.active(false);

												WorldGen.SquareTileFrame(k, l, false);
												break;
											case 9:
												tile.active(false);
												WorldGen.PlaceTile(k, l, TileID.Platforms, true, true, -1, 0); //platform //platform
												break;

										}
									}
								}
							}
						}
					}
					if (variation == 10)
					{
						int[,] _structure = {
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0},
							{0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0},
							{0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,1,0,2,0,0,0,0,0,3,0,0,0},
							{0,0,0,0,0,1,1,1,1,1,1,1,0,3,0,0,0},
							{0,4,4,5,6,6,7,7,7,7,7,6,6,6,5,4,0},
							{0,8,5,5,5,7,7,7,7,7,7,7,5,5,5,9,0},
							{0,0,0,8,5,5,5,5,5,5,5,5,5,9,0,0,0},
							{0,3,0,0,0,8,5,5,5,5,5,9,0,0,0,0,0},
							{0,3,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0},
							{0,3,0,0,0,0,0,0,0,0,0,0,0,0,3,0,3},
							{6,6,0,3,0,0,0,0,0,0,0,0,3,0,3,6,6},
							{7,6,6,6,0,3,0,0,0,0,0,0,3,6,6,6,7},
							{7,7,7,6,6,3,0,0,0,0,0,0,6,6,7,7,7},
							{7,7,7,7,6,6,0,0,0,0,0,6,6,7,7,7,7}
						};
						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _structure.GetLength(1));
						PosY -= (int)(.5f * _structure.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
						{
							for (int i = 0; i < _structure.GetLength(0); i++)
							{
								for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_structure[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
												{
													tile.active(false);
													tile.halfBrick(false);
													tile.slope(0);
												}
												break;
											case 1:
												tile.active(true);
												tile.type = (ushort)mod.TileType("PyramidSlabTile");
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 2:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, (ushort)mod.TileType("PyramidChestTile"), true, true, -1, 0);
												}
												break;
											case 3:
												tile.active(true);
												tile.type = 170;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 4:
												tile.active(true);
												tile.type = 189;
												tile.slope(0);
												tile.halfBrick(true);
												break;
											case 5:
												tile.active(true);
												tile.type = 189;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 6:
												tile.active(true);
												tile.type = 2;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 7:
												tile.active(true);
												tile.type = 0;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 8:
												tile.active(true);
												tile.type = 189;
												tile.slope(4);
												tile.halfBrick(false);
												break;
											case 9:
												tile.active(true);
												tile.type = 189;
												tile.slope(3);
												tile.halfBrick(false);
												break;
										}
									}
								}
							}
						}
					}
					if (variation == 11)
					{
						int[,] _structure = {
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,1,0,0,0,0,0,0,0,0,0,0,0,2,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,3,0,0,0,0,0,0,0,0,0,0,4,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0},
							{0,0,0,0,0,0,0,0,5,0,0,0,0,0,7,8,9},
							{10,0,0,11,12,12,0,13,13,13,0,0,6,0,14,8,9},
							{10,10,11,15,0,0,0,0,0,0,0,0,8,16,0,8,9},
							{10,12,15,11,12,17,0,0,0,0,0,0,8,8,0,8,9},
							{12,15,0,12,12,12,0,0,0,0,0,0,8,8,0,8,8},
							{12,0,0,12,10,12,0,0,0,0,0,9,8,8,0,0,8},
							{12,18,0,12,20,10,0,0,0,0,0,9,20,8,19,0,8},
							{12,12,12,12,10,10,0,0,0,0,0,9,8,8,8,8,8}
						};
						int PosX = x;
						int PosY = y;
						PosX -= (int)(.5f * _structure.GetLength(1));
						PosY -= (int)(.5f * _structure.GetLength(0));
						//i = vertical, j = horizontal
						for (int confirmPlatforms = 0; confirmPlatforms < 2; confirmPlatforms++)    //Increase the iterations on this outermost for loop if tabletop-objects are not properly spawning
						{
							for (int i = 0; i < _structure.GetLength(0); i++)
							{
								for (int j = _structure.GetLength(1) - 1; j >= 0; j--)
								{
									int k = PosX + j;
									int l = PosY + i;
									if (WorldGen.InWorld(k, l, 30))
									{
										Tile tile = Framing.GetTileSafely(k, l);
										switch (_structure[i, j])
										{
											case 0:
												if (confirmPlatforms == 0)
												{
													tile.active(false);
													tile.halfBrick(false);
													tile.slope(0);
												}
												break;
											case 1:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, 240, true, true, -1, 12);
												}
												break;
											case 2:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, 240, true, true, -1, 13);
												}
												break;
											case 3:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, 242, true, true, -1, 13);
												}
												break;
											case 4:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, 242, true, true, -1, 8);
												}
												break;
											case 5:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, 243, true, true, -1, 0);
												}
												break;
											case 6:
												tile.active(true);
												tile.type = 25;
												tile.slope(0);
												tile.halfBrick(true);
												break;
											case 7:
												tile.active(true);
												tile.type = 25;
												tile.slope(2);
												tile.halfBrick(false);
												break;
											case 8:
												tile.active(true);
												tile.type = 25;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 9:
												tile.active(true);
												tile.type = 23;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 10:
												tile.active(true);
												tile.type = 199;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 11:
												tile.active(true);
												tile.type = 203;
												tile.slope(2);
												tile.halfBrick(false);
												break;
											case 12:
												tile.active(true);
												tile.type = 203;
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 13:
												if (confirmPlatforms == 0)
													tile.active(false);
												WorldGen.PlaceTile(k, l, 19, true, true, -1, 0);
												tile.slope(0);
												tile.halfBrick(false);
												break;
											case 14:
												tile.active(true);
												tile.type = 25;
												tile.slope(4);
												tile.halfBrick(false);
												break;
											case 15:
												tile.active(true);
												tile.type = 203;
												tile.slope(3);
												tile.halfBrick(false);
												break;
											case 16:
												tile.active(true);
												tile.type = 25;
												tile.slope(1);
												tile.halfBrick(false);
												break;
											case 17:
												tile.active(true);
												tile.type = 203;
												tile.slope(1);
												tile.halfBrick(false);
												break;
											case 18:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, (ushort)mod.TileType("CrystalStatue"), true, true, -1, 0);
												}
												break;
											case 19:
												if (confirmPlatforms == 1)
												{
													tile.active(false);
													tile.slope(0);
													tile.halfBrick(false);
													WorldGen.PlaceTile(k, l, (ushort)mod.TileType("ManaStatue"), true, true, -1, 0);
												}
												break;
											case 20:
												tile.active(true);
												tile.type = 0;
												tile.slope(0);
												tile.halfBrick(false);
												break;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		public static void GenerateInfection(Vector2 pos, Mod mod, bool item = false)
		{
			int[] sumRolls = new int[11];
			int[] sumRolls2 = new int[9];
			int i = (int)pos.X / 16;
			int j = (int)pos.Y / 16;
			int i2 = i;
			int amt = 1;
			if (item)
				amt = Main.rand.Next(2) + 2;
			for (int k = 0; k < amt; k++)
			{
				sumRolls = new int[11];
				sumRolls2 = new int[9];
				Tile tileCenter = Framing.GetTileSafely(i, j - 3);
				if (tileCenter.type == mod.TileType("PyramidSlabTile") || item)
				{
					for (int k2 = 0; k2 < 30; k2++)
					{
						int rand = Main.rand.Next(5);
						int rand2 = Main.rand.Next(4);
						int rand3 = Main.rand.Next(4);
						int sum = rand + rand2 + rand3;
						if (sumRolls[sum] < 9)
						{
							sumRolls[sum]++;
						}
						else
							k2--;
					}
					for (int k2 = 0; k2 < sumRolls.Length; k2++)
					{
						for (int k3 = 0; k3 < sumRolls[k2] + 1; k3++)
						{
							Tile tile = Framing.GetTileSafely(i + k2 - 5, j - k3 - 3);
							if (Main.rand.Next(40) != 0 && (tile.type == mod.TileType("PyramidSlabTile") || !tile.active()))
							{
								if (item)
									WorldGen.PlaceTile(i + k2 - 5, j - k3 - 3, (ushort)mod.TileType("CursedHive"));
								tile.type = (ushort)mod.TileType("CursedHive");
								tile.active(true);
							}
						}
					}
					for (int k2 = 0; k2 < 20; k2++)
					{
						int rand = Main.rand.Next(5);
						int rand2 = Main.rand.Next(5);
						int sum = rand + rand2;
						if (sumRolls2[sum] < 3)
						{
							sumRolls2[sum]++;
						}
						else
							k2--;
					}
					for (int k2 = 0; k2 < sumRolls2.Length; k2++)
					{
						for (int k3 = 0; k3 < sumRolls2[k2]; k3++)
						{
							Tile tile = Framing.GetTileSafely(i + k2 - 4, j + k3 - 2);
							if (Main.rand.Next(20) != 0 && (tile.type == mod.TileType("PyramidSlabTile") || !tile.active()))
							{
								if (item)
									WorldGen.PlaceTile(i + k2 - 4, j + k3 - 2, (ushort)mod.TileType("CursedHive"));
								tile.type = (ushort)mod.TileType("CursedHive");
								tile.active(true);
							}
						}
					}
				}
				sumRolls = new int[11];
				sumRolls2 = new int[9];
				tileCenter = Framing.GetTileSafely(i, j + 3);
				if (tileCenter.type == mod.TileType("PyramidSlabTile") || item)
				{
					for (int k2 = 0; k2 < 30; k2++)
					{
						int rand = Main.rand.Next(5);
						int rand2 = Main.rand.Next(4);
						int rand3 = Main.rand.Next(4);
						int sum = rand + rand2 + rand3;
						if (sumRolls[sum] < 9)
						{
							sumRolls[sum]++;
						}
						else
							k2--;
					}
					for (int k2 = 0; k2 < sumRolls.Length; k2++)
					{
						for (int k3 = 0; k3 < sumRolls[k2] + 1; k3++)
						{
							Tile tile = Framing.GetTileSafely(i + k2 - 5, j + k3 + 3);
							if (Main.rand.Next(40) != 0 && (tile.type == mod.TileType("PyramidSlabTile") || !tile.active()))
							{
								if (item)
									WorldGen.PlaceTile(i + k2 - 5, j + k3 + 3, (ushort)mod.TileType("CursedHive"));
								tile.type = (ushort)mod.TileType("CursedHive");
								tile.active(true);
							}
						}
					}
					for (int k2 = 0; k2 < 20; k2++)
					{
						int rand = Main.rand.Next(5);
						int rand2 = Main.rand.Next(5);
						int sum = rand + rand2;
						if (sumRolls2[sum] < 3)
						{
							sumRolls2[sum]++;
						}
						else
							k2--;
					}
					for (int k2 = 0; k2 < sumRolls2.Length; k2++)
					{
						for (int k3 = 0; k3 < sumRolls2[k2]; k3++)
						{
							Tile tile = Framing.GetTileSafely(i + k2 - 4, j - k3 + 2);
							if (Main.rand.Next(20) != 0 && (tile.type == mod.TileType("PyramidSlabTile") || !tile.active()))
							{
								if (item)
									WorldGen.PlaceTile(i + k2 - 4, j - k3 + 2, (ushort)mod.TileType("CursedHive"));
								tile.type = (ushort)mod.TileType("CursedHive");
								tile.active(true);
							}
						}
					}
				}
				i = Main.rand.Next(-30, 31) + i2;
			}
		}
		public static void GeneratePyramidCrystalRoom(Mod mod, int spawnX, int spawnY)
		{
			int i;
			int j;
			float deg = WorldGen.genRand.Next(360);
			for (int k = 0; k < 3; k++)
			{
				Vector2 offset = new Vector2(k * 4 + WorldGen.genRand.Next(2 + 4 * k), 0).RotatedBy(MathHelper.ToRadians(deg));
				offset.Y *= 0.8f;
				i = spawnX + (int)offset.X;
				j = spawnY + (int)offset.Y;
				GeneratePyramidOval(mod, i, j, 12 + WorldGen.genRand.Next(10 - k * 2), 10 + WorldGen.genRand.Next(8 - k * 2));
				deg += WorldGen.genRand.Next(120);
			}
		}
		public static void GeneratePyramidPath(Mod mod, int spawnX, int spawnY, int endX, int endY, int direction = 1)
		{
			Vector2 start = new Vector2(spawnX, spawnY);
			Vector2 end = new Vector2(endX, endY);
			float lengthToEnd = Vector2.Distance(start, end) * 0.5f;
			float rotationToEnd = (start - end).ToRotation();
			Vector2 midPoint = (start + end) * 0.5f;
			spawnX = (int)midPoint.X;
			spawnY = (int)midPoint.Y;
			float yDistMult = Main.rand.NextFloat(-0.25f, 1.00f) * direction;
			for (int i = 0; i < 18; i++)
			{
				Vector2 circularLocation = new Vector2(lengthToEnd, 0).RotatedBy(MathHelper.ToRadians(i * 10));
				circularLocation.Y *= yDistMult;
				circularLocation = circularLocation.RotatedBy(rotationToEnd);
				GeneratePyramidOval(mod, spawnX + (int)circularLocation.X, spawnY + (int)circularLocation.Y, 6, 6, 0.75f);
			}
			GeneratePyramidCrystalRoom(mod, endX, endY);
			for (int j = -3; j <= -1; j++)
				for (int i = j; i <= -j; i++)
				{
					Tile tile = Framing.GetTileSafely(endX + i, endY + j + 4);
					tile.type = (ushort)ModContent.TileType<CursedTumorTile>();
					tile.active(true);
				}
			WorldGen.PlaceTile(endX, endY, ModContent.TileType<RubyKeystoneTile>(), false, true);
		}
		public static void GeneratePyramidOval(Mod mod, int spawnX, int spawnY, int radius = 14, int radiusY = 14, float thickMult = 1f)
		{
			float scale = radiusY / (float)radius;
			float invertScale = (float)radius / radiusY;
			for (int x = -radius; x <= radius; x++)
			{
				for (float y = -radius; y <= radius; y += (invertScale * 0.85f))
				{
					float radialMod = Main.rand.NextFloat(2.1f, 4.1f) * thickMult;
					if (Math.Sqrt(x * x + y * y) <= radius + 0.5)
					{
						int xPosition6 = spawnX + x;
						int yPosition6 = spawnY + (int)(y * scale);
						Tile tile = Framing.GetTileSafely(xPosition6, yPosition6);
						bool capable = true;
						if (tile.wall == ModContent.WallType<PyramidWallTile>() && !tile.active())
							capable = false;
						if (Math.Sqrt(x * x + y * y) >= radius - radialMod && tile.wall != ModContent.WallType<CursedTumorWallTile>() && capable)
						{
							ConvertNearbyTiles(mod, xPosition6, yPosition6);
							tile.type = (ushort)ModContent.TileType<CursedTumorTile>();
							tile.active(true);
							if (Math.Sqrt(x * x + y * y) <= radius - (radialMod - 1))
								tile.wall = (ushort)ModContent.WallType<CursedTumorWallTile>();
						}
						else
						{
							tile.wall = (ushort)ModContent.WallType<CursedTumorWallTile>();
							tile.active(false);
						}
					}
				}
			}
		}
		public static void ConvertNearbyTiles(Mod mod, int spawnX, int spawnY)
		{
			int radius = 3;
			for (int x = -radius; x <= radius; x++)
			{
				for (int y = -radius; y <= radius; y++)
				{
					if (Math.Sqrt(x * x + y * y) <= radius + 0.5)
					{
						int xPosition6 = spawnX + x;
						int yPosition6 = spawnY + y;
						Tile tile = Framing.GetTileSafely(xPosition6, yPosition6);
						if (tile.active() && Main.rand.NextBool((int)Math.Sqrt(x * x + y * y) + 2) && tile.type == (ushort)ModContent.TileType<PyramidSlabTile>())
						{
							tile.type = (ushort)ModContent.TileType<CursedHive>();
							tile.active(true);
						}
					}
				}
			}
		}
	}
}